This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-06T08:59:45.973Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
cmd/api/api.go
cmd/main.go
cmd/migrate/main.go
cmd/migrate/migrations/20241202144458_add-book-table.down.sql
cmd/migrate/migrations/20241202144458_add-book-table.up.sql
config/env.go
controller/book.go
controller/healthcheck.go
controller/tests/book_test.go
controller/tests/healthcheck_test.go
db/db.go
docker-compose.yml
go.mod
go.sum
Makefile
repository/book_interface.go
repository/book.go
repository/errors.go
repository/tests/book_test.go
service/book_interface.go
service/book.go
service/healthcheck_interface.go
service/healthcheck.go
service/tests/book_test.go
service/tests/healthcheck_test.go
types/books.go
types/healthcheck.go
utils/utils.go

================================================================
Repository Files
================================================================

================
File: cmd/api/api.go
================
package api

import (
	"database/sql"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/controller"
	"github.com/hoyci/book-store-api/repository"
	"github.com/hoyci/book-store-api/service"
)

type APIServer struct {
	addr   string
	db     *sql.DB
	router *mux.Router
}

func NewApiServer(addr string, db *sql.DB) *APIServer {
	return &APIServer{
		addr:   addr,
		db:     db,
		router: nil,
	}
}

func (s *APIServer) SetupRouter(
	healthcheckService service.HealthcheckServiceInterface,
	bookService service.BookServiceInterface,
) *mux.Router {
	router := mux.NewRouter()
	subrouter := router.PathPrefix("/api/v1").Subrouter()

	healthcheckController := controller.NewHealthcheckController(healthcheckService)
	subrouter.HandleFunc("/healthcheck", healthcheckController.HandleHealthcheck).Methods("GET")

	bookController := controller.NewBookController(bookService)
	subrouter.HandleFunc("/book", bookController.HandleCreateBook).Methods(http.MethodPost)
	subrouter.HandleFunc("/book/{id}", bookController.HandleGetBookByID).Methods(http.MethodGet)
	subrouter.HandleFunc("/book/{id}", bookController.HandleDeleteBookByID).Methods(http.MethodDelete)

	s.router = router

	return router
}

func (s *APIServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if s.router == nil {
		healthcheckService := service.NewHealthcheckService(config.Envs)

		bookRepository := repository.NewBookRepository(s.db)
		bookService := service.NewBookService(bookRepository)

		s.SetupRouter(healthcheckService, bookService)
	}
	s.router.ServeHTTP(w, r)
}

================
File: cmd/main.go
================
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/db"
)

func main() {
	db := db.NewPGStorage()

	path := fmt.Sprintf("127.0.0.1:%s", config.Envs.Port)
	apiServer := api.NewApiServer(path, db)

	log.Println("Listening on:", path)
	http.ListenAndServe(path, apiServer)
}

// TODO: Corrigir error de last insert no book repository ✅
// TODO: Adicionar repository dinâmico para dar update no book
// TODO: Adicionar testes faltando para o book service e controller

================
File: cmd/migrate/main.go
================
package main

import (
	"database/sql"
	"log"
	"os"

	"github.com/golang-migrate/migrate/v4"
	pgMigrate "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"github.com/hoyci/book-store-api/config"
	_ "github.com/lib/pq"
)

func main() {
	db, err := sql.Open("postgres", config.Envs.DatabaseURL)
	if err != nil {
		log.Fatalf("Failed to connect to the database: %v", err)
	}
	defer db.Close()

	driver, err := pgMigrate.WithInstance(db, &pgMigrate.Config{})
	if err != nil {
		log.Fatalf("Error creating migrate driver: %v", err)
	}

	m, err := migrate.NewWithDatabaseInstance(
		"file://cmd/migrate/migrations",
		"public",
		driver,
	)
	if err != nil {
		log.Fatalf("Error creating migrate instance: %v", err)
	}

	cmd := os.Args[len(os.Args)-1]
	switch cmd {
	case "up":
		if err := m.Up(); err != nil && err != migrate.ErrNoChange {
			log.Fatalf("Migration up failed: %v", err)
		}
		log.Println("Migrations applied successfully.")
	case "down":
		if err := m.Down(); err != nil && err != migrate.ErrNoChange {
			log.Fatalf("Migration down failed: %v", err)
		}
		log.Println("Migrations reverted successfully.")
	default:
		log.Println("No command provided. Use 'up' or 'down'.")
	}
}

================
File: cmd/migrate/migrations/20241202144458_add-book-table.down.sql
================
DROP TABLE books;

================
File: cmd/migrate/migrations/20241202144458_add-book-table.up.sql
================
CREATE TABLE IF NOT EXISTS books (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,     
    author VARCHAR(255),   
    genres TEXT[],         
    release_year INT,      
    number_of_pages INT,    
    image_url VARCHAR(255),
    created_at TIMESTAMP NOT NULL
);

================
File: config/env.go
================
package config

import (
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	Port        string
	Environment string
	DatabaseURL string
	// DBUser                 string
	// DBPassword             string
	// DBAddress              string
	// DBName                 string
	// JWTSecret              string
	// JWTExpirationInSeconds int64
}

var Envs = initConfig()

func initConfig() Config {
	godotenv.Load()

	return Config{
		Port:        getEnv("PORT", "8080"),
		Environment: getEnv("ENV", "development"),
		DatabaseURL: getEnv("DATABASE_URL", "postgresql://user:password@localhost:5432/postgres?sslmode=disable"),
		// DBUser:                 getEnv("DB_USER", "admin"),
		// DBPassword:             getEnv("DB_PASSWORD", "password"),
		// DBAddress:              fmt.Sprintf("%s:%s", getEnv("DB_HOST", "127.0.0.1"), getEnv("DB_PORT", "3306")),
		// DBName:                 getEnv("DB_NAME", "ecom"),
		// JWTSecret:              getEnv("JWT_SECRET", "not-secret-secret-anymore?"),
		// JWTExpirationInSeconds: getEnvAsInt("JWT_EXP", 3600*24*7),
	}
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}

	return fallback
}

// func getEnvAsInt(key string, fallback int64) int64 {
// 	if value, ok := os.LookupEnv(key); ok {
// 		i, err := strconv.ParseInt(value, 10, 64)
// 		if err != nil {
// 			return fallback
// 		}

// 		return i
// 	}

// 	return fallback
// }

================
File: controller/book.go
================
package controller

import (
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-playground/validator/v10"
	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/repository"
	"github.com/hoyci/book-store-api/service"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
)

var validate = validator.New()

type BookController struct {
	Service service.BookServiceInterface
}

func NewBookController(service service.BookServiceInterface) *BookController {
	return &BookController{
		Service: service,
	}
}

func (c *BookController) HandleCreateBook(w http.ResponseWriter, r *http.Request) {
	var payload types.CreateBookPayload
	if err := utils.ParseJSON(r, &payload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, fmt.Errorf("invalid input"))
		return
	}

	if err := validate.Struct(payload); err != nil {
		var errorMessages []string
		errors := err.(validator.ValidationErrors)

		for _, e := range errors {
			errorMessages = append(errorMessages, fmt.Sprintf("Field '%s' is invalid: %s", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, fmt.Errorf("%v", errorMessages))
		return
	}

	id, err := c.Service.Create(r.Context(), payload)
	if err != nil {
		var insertErr *repository.InsertError
		var idErr *repository.LastInsertIDError

		if errors.As(err, &insertErr) {
			utils.WriteError(w, http.StatusInternalServerError, insertErr)
			return
		}

		if errors.As(err, &idErr) {
			utils.WriteError(w, http.StatusInternalServerError, idErr)
			return
		}

		utils.WriteError(w, http.StatusInternalServerError, fmt.Errorf("unexpected error: %w", err))
		return
	}

	utils.WriteJSON(w, http.StatusCreated, map[string]int64{"id": id})
}

func (c *BookController) HandleGetBookByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, fmt.Errorf("invalid book ID: must be a positive integer"))
		return
	}

	book, err := c.Service.GetByID(r.Context(), id)
	if err != nil {
		var notFoundErr *repository.ResourceNotFoundError
		var dbErr *repository.InternalDatabaseError

		if errors.As(err, &notFoundErr) {
			utils.WriteError(w, http.StatusNotFound, notFoundErr)
			return
		}

		if errors.As(err, &dbErr) {
			utils.WriteError(w, http.StatusInternalServerError, dbErr)
			return
		}

		utils.WriteError(w, http.StatusInternalServerError, fmt.Errorf("unexpected error: %w", err))
		return
	}

	utils.WriteJSON(w, http.StatusOK, book)
}

func (c *BookController) HandleDeleteBookByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, fmt.Errorf("invalid book ID: must be a positive integer"))
		return
	}

	err = c.Service.DeleteByID(r.Context(), id)
	if err != nil {
		var notFoundErr *repository.ResourceNotFoundError
		var dbErr *repository.InternalDatabaseError

		if errors.As(err, &notFoundErr) {
			utils.WriteError(w, http.StatusNotFound, notFoundErr)
			return
		}

		if errors.As(err, &dbErr) {
			utils.WriteError(w, http.StatusInternalServerError, dbErr)
			return
		}

		utils.WriteError(w, http.StatusInternalServerError, fmt.Errorf("unexpected error: %w", err))
		return
	}

}

================
File: controller/healthcheck.go
================
package controller

import (
	"net/http"

	"github.com/hoyci/book-store-api/service"
	"github.com/hoyci/book-store-api/utils"
)

type HealthcheckController struct {
	Service service.HealthcheckServiceInterface
}

func NewHealthcheckController(service service.HealthcheckServiceInterface) *HealthcheckController {
	return &HealthcheckController{
		Service: service,
	}
}

func (h *HealthcheckController) HandleHealthcheck(w http.ResponseWriter, r *http.Request) {
	response := h.Service.HandleHealthcheck(r.Context())

	utils.WriteJSON(w, http.StatusOK, response)
}

================
File: controller/tests/book_test.go
================
package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/repository"
	"github.com/hoyci/book-store-api/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockBookService struct {
	mock.Mock
}

func (m *MockBookService) Create(ctx context.Context, payload types.CreateBookPayload) (int64, error) {
	args := m.Called(ctx, payload)
	return args.Get(0).(int64), args.Error(1)
}

func (m *MockBookService) GetByID(ctx context.Context, id int) (*types.Book, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.Book), args.Error(1)
}

func TestHandleGetBookByID(t *testing.T) {
	mockService := new(MockBookService)

	apiServer := api.NewApiServer(":8080", nil)
	router := apiServer.SetupRouter(nil, mockService)

	ts := httptest.NewServer(router)
	defer ts.Close()

	t.Run("it should throw an error when call endpoint without book ID", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/book", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusMethodNotAllowed, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong ID", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/book/johndoe", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"invalid book ID: must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return succssefully status and body when call endpoint with valid body", func(t *testing.T) {
		mockService.On("GetByID", mock.Anything, 1).Return(&types.Book{
			ID:            1,
			Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}, nil)

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/book/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{
			"id": 1,
			"name": "Go Programming",
			"description": "A book about Go programming",
			"author": "John Doe",
			"genres": ["Programming"],
			"releaseYear": 2024,
			"numberOfPages": 300,
			"imageUrl": "http://example.com/go.jpg",
			"createdAt": "0001-01-01T00:00:00Z"
		}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

func TestHandleCreateook(t *testing.T) {
	mockService := new(MockBookService)

	apiServer := api.NewApiServer(":8080", nil)
	router := apiServer.SetupRouter(nil, mockService)

	ts := httptest.NewServer(router)
	defer ts.Close()

	t.Run("it should throw an error when body is not a valid JSON", func(t *testing.T) {
		invalidBody := bytes.NewReader([]byte("INVALID JSON"))
		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/book", invalidBody)
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"invalid input"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is a valid JSON but missing key", func(t *testing.T) {
		mockService.On("Create", mock.Anything, mock.Anything).Return(int64(1), nil)

		payload := types.CreateBookPayload{
			// Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/book", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"[Field 'Name' is invalid: required]"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should successfully create a book", func(t *testing.T) {
		mockService.On("Create", mock.Anything, mock.Anything).Return(int64(1), nil)

		payload := types.CreateBookPayload{
			Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/book", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusCreated, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"id":1}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw a database insert error", func(t *testing.T) {
		mockService.On("Create", mock.Anything, mock.Anything).Return(int64(0), &repository.InsertError{
			Entity: "Go Programming",
			Err:    errors.New("duplicate key"),
		})

		payload := types.CreateBookPayload{
			Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/book", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusInternalServerError, res.StatusCode)

		responseBody, _ := io.ReadAll(res.Body)
		expected := `{"error":"failed to insert entity 'Go Programming': duplicate key"}`
		assert.JSONEq(t, expected, string(responseBody))
	})
}

================
File: controller/tests/healthcheck_test.go
================
package controller

import (
	"context"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockhHealthcheckService struct {
	mock.Mock
}

func (m *MockhHealthcheckService) HandleHealthcheck(ctx context.Context) *types.HealthcheckResponse {
	args := m.Called(ctx)
	return args.Get(0).(*types.HealthcheckResponse)
}

func TestHandleHealthChec(t *testing.T) {
	mockService := new(MockhHealthcheckService)

	apiServer := api.NewApiServer(":8080", nil)
	router := apiServer.SetupRouter(mockService, nil)

	ts := httptest.NewServer(router)
	defer ts.Close()

	t.Run("it should return environment as production", func(t *testing.T) {
		mockService.On("HandleHealthcheck", mock.Anything).Return(&types.HealthcheckResponse{
			Status: "available",
			SystemInfo: map[string]string{
				"environment": "production",
			},
		})

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/healthcheck", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"status":"available","system_info":{"environment":"production"}}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

}

================
File: db/db.go
================
package db

import (
	"database/sql"
	"log"

	"github.com/hoyci/book-store-api/config"
)

func NewPGStorage() *sql.DB {
	db, err := sql.Open("postgres", config.Envs.DatabaseURL)
	if err != nil {
		log.Fatalf("Failed to open database connection: %v", err)
	}

	return db
}

================
File: docker-compose.yml
================
services:
  db:
    image: bitnami/postgresql:latest
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: postgres
    ports:
      - "5432:5432"
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:

================
File: go.mod
================
module github.com/hoyci/book-store-api

go 1.23.1

require (
	github.com/golang-migrate/migrate/v4 v4.18.1
	github.com/joho/godotenv v1.5.1
	github.com/stretchr/testify v1.9.0
)

require (
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/kr/pretty v0.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	go.uber.org/atomic v1.11.0 // indirect
	golang.org/x/crypto v0.27.0 // indirect
	golang.org/x/net v0.29.0 // indirect
	golang.org/x/sys v0.25.0 // indirect
	golang.org/x/text v0.18.0 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
)

require (
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/go-playground/validator/v10 v10.23.0
	github.com/gorilla/mux v1.8.1
	github.com/lib/pq v1.10.9
	github.com/pmezard/go-difflib v1.0.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: go.sum
================
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 h1:L/gRVlceqvL25UVaW/CKtUDjefjrs0SPonmDGUVOYP0=
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/DATA-DOG/go-sqlmock v1.5.2 h1:OcvFkGmslmlZibjAjaHm3L//6LiuBgolP7OputlJIzU=
github.com/DATA-DOG/go-sqlmock v1.5.2/go.mod h1:88MAG/4G7SMwSE3CeA0ZKzrT5CiOU3OJ+JlNzwDqpNU=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dhui/dktest v0.4.3 h1:wquqUxAFdcUgabAVLvSCOKOlag5cIZuaOjYIBOWdsR0=
github.com/dhui/dktest v0.4.3/go.mod h1:zNK8IwktWzQRm6I/l2Wjp7MakiyaFWv4G1hjmodmMTs=
github.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/docker/docker v27.2.0+incompatible h1:Rk9nIVdfH3+Vz4cyI/uhbINhEZ/oLmc+CBXmH6fbNk4=
github.com/docker/docker v27.2.0+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.23.0 h1:/PwmTwZhS0dPkav3cdK9kV1FsAmrL8sThn8IHr/sO+o=
github.com/go-playground/validator/v10 v10.23.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-migrate/migrate/v4 v4.18.1 h1:JML/k+t4tpHCpQTCAD62Nu43NUFzHY4CV3uAuvHGC+Y=
github.com/golang-migrate/migrate/v4 v4.18.1/go.mod h1:HAX6m3sQgcdO81tdjn5exv20+3Kb13cmGli1hrD6hks=
github.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=
github.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=
github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=
github.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=
github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46/go.mod h1:yyMNCyc/Ib3bDTKd379tNMpB/7/H5TjM2Y9QJ5THLbE=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
github.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=
github.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 h1:TT4fX+nBOA/+LUkobKGW1ydGcn+G3vRw9+g5HwCphpk=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0/go.mod h1:L7UH0GbB0p47T4Rri3uHjbpCFYrVrwc1I25QhNPiGK8=
go.opentelemetry.io/otel v1.29.0 h1:PdomN/Al4q/lN6iBJEN3AwPvUiHPMlt93c8bqTG5Llw=
go.opentelemetry.io/otel v1.29.0/go.mod h1:N/WtXPs1CNCUEx+Agz5uouwCba+i+bJGFicT8SR4NP8=
go.opentelemetry.io/otel/metric v1.29.0 h1:vPf/HFWTNkPu1aYeIsc98l4ktOQaL6LeSoeV2g+8YLc=
go.opentelemetry.io/otel/metric v1.29.0/go.mod h1:auu/QWieFVWx+DmQOUMgj0F8LHWdgalxXqvp7BII/W8=
go.opentelemetry.io/otel/trace v1.29.0 h1:J/8ZNK4XgR7a21DZUAsbF8pZ5Jcw1VhACmnYt39JTi4=
go.opentelemetry.io/otel/trace v1.29.0/go.mod h1:eHl3w0sp3paPkYstJOmAimxhiFXPg+MMTlEh3nsQgWQ=
go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
golang.org/x/crypto v0.27.0 h1:GXm2NjJrPaiv/h1tb2UH8QfgC/hOf/+z0p6PT8o1w7A=
golang.org/x/crypto v0.27.0/go.mod h1:1Xngt8kV6Dvbssa53Ziq6Eqn0HqbZi5Z6R0ZpwQzt70=
golang.org/x/net v0.29.0 h1:5ORfpBpCs4HzDYoodCDBbwHzdR5UrLBZ3sOnUJmFoHo=
golang.org/x/net v0.29.0/go.mod h1:gLkgy8jTGERgjzMic6DS9+SP0ajcu6Xu3Orq/SpETg0=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=
golang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

================
File: Makefile
================
build:
	@go build -o bin/ecom cmd/main.go

test:
	@go test -v ./...

run: build
	@./bin/ecom

# migrate create -ext sql -dir cmd/migrate/migrations add-user-table
migration:
	@migration create -ext sql -dir cmd/migrate/migrations $(filter-out $@,$(MAKECMDGOALS))

# go run cmd/migrate/main.go up
@migrate-up:
	@go run cmd/migrate/main.go up

# go run cmd/migrate/main.go down
@migrate-down:
	@go run cmd/migrate/main.go down

================
File: repository/book_interface.go
================
package repository

import (
	"context"

	"github.com/hoyci/book-store-api/types"
)

type BookRepositoryInterface interface {
	Create(ctx context.Context, book types.CreateBookPayload) (int64, error)
	GetByID(ctx context.Context, id int) (*types.Book, error)
	DeleteByID(ctx context.Context, id int) error
}

================
File: repository/book.go
================
package repository

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/hoyci/book-store-api/types"
	"github.com/lib/pq"
)

type BookRepository struct {
	db *sql.DB
}

func NewBookRepository(db *sql.DB) *BookRepository {
	return &BookRepository{db: db}
}

func (s *BookRepository) Create(ctx context.Context, book types.CreateBookPayload) (int64, error) {
	var id int64
	err := s.db.QueryRowContext(
		ctx,
		"INSERT INTO books (name, description, author, genres, release_year, number_of_pages, image_url) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id",
		book.Name,
		book.Description,
		book.Author,
		pq.Array(book.Genres),
		book.ReleaseYear,
		book.NumberOfPages,
		book.ImageUrl,
	).Scan(&id)

	if err != nil {
		return 0, &InsertError{
			Entity: book.Name,
			Err:    err,
		}
	}

	return id, nil
}

func (s *BookRepository) GetByID(ctx context.Context, id int) (*types.Book, error) {
	book := &types.Book{}

	err := s.db.QueryRowContext(ctx, "SELECT id, name, description, author, genres, release_year, number_of_pages, image_url, created_at FROM books WHERE id = $1 and deleted_at = null", id).
		Scan(
			&book.ID,
			&book.Name,
			&book.Description,
			&book.Author,
			pq.Array(&book.Genres),
			&book.ReleaseYear,
			&book.NumberOfPages,
			&book.ImageUrl,
			&book.CreatedAt,
		)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, &ResourceNotFoundError{ID: id}
		}
		return nil, &InternalDatabaseError{
			Message: fmt.Sprintf("failed to fetch book by ID %d", id),
			Err:     err,
		}
	}

	return book, nil
}

// VErificar se o body está correto no controller
// Verificar se há valores para serem atualizados no controller
func (s *BookRepository) UpdateByID(ctx context.Context, id int64, updates types.BookUpdatePayload) error {
	query := "UPDATE books SET "
	args := []any{}
	counter := 1

	fields := []struct {
		name  string
		value any
	}{
		{"name", updates.Name},
		{"description", updates.Description},
		{"author", updates.Author},
		{"genres", updates.Genres},
		{"release_year", updates.ReleaseYear},
		{"number_of_pages", updates.NumberOfPages},
		{"image_url", updates.ImageUrl},
	}

	for _, field := range fields {
		if field.value != nil {
			query += fmt.Sprintf("%s = $%d, ", field.name, counter)
			if ptr, ok := field.value.(*[]string); ok {
				args = append(args, pq.Array(*ptr))
			} else {
				args = append(args, field.value)
			}
			counter++
		}
	}

	if len(args) == 0 {
		return nil
	}

	query = query[:len(query)-2] + " WHERE id = $%d"
	args = append(args, id)
	query = fmt.Sprintf(query, counter)

	_, err := s.db.ExecContext(ctx, query, args...)
	if err != nil {
		return &UpdateError{
			Entity: "book",
			ID:     int(id),
			Err:    err,
		}
	}

	return nil
}

func (s *BookRepository) DeleteByID(ctx context.Context, id int) (int64, error) {
	var id_returned int64
	err := s.db.QueryRowContext(
		ctx,
		"UPDATE books SET deleted_at = $2 WHERE id = $1 RETURNING id",
		id,
		time.Now(),
	).Scan(&id_returned)
	if err != nil {
		return 0, &DeleteError{
			Entity: "book",
			ID:     id,
			Err:    err,
		}
	}

	return id_returned, nil
}

================
File: repository/errors.go
================
package repository

import "fmt"

type ResourceNotFoundError struct {
	ID int
}

type InternalDatabaseError struct {
	Message string
	Err     error
}

type InsertError struct {
	Entity string
	Err    error
}

type LastInsertIDError struct {
	Err error
}

type UpdateError struct {
	Entity string
	ID     int
	Err    error
}

type DeleteError struct {
	Entity string
	ID     int
	Err    error
}

func (e *ResourceNotFoundError) Error() string {
	return fmt.Sprintf("resource with ID %d not found", e.ID)
}

func (e *InternalDatabaseError) Error() string {
	return fmt.Sprintf("internal database error: %s", e.Message)
}

func (e *InternalDatabaseError) Unwrap() error {
	return e.Err
}

func (e *InsertError) Error() string {
	return fmt.Sprintf("failed to insert entity '%s': %v", e.Entity, e.Err)
}

func (e *InsertError) Unwrap() error {
	return e.Err
}

func (e *LastInsertIDError) Error() string {
	return fmt.Sprintf("failed to fetch last inserted ID: %v", e.Err)
}

func (e *LastInsertIDError) Unwrap() error {
	return e.Err
}

func (e *UpdateError) Error() string {
	return fmt.Sprintf("failed to update entity '%s' with id '%d': %v", e.Entity, e.ID, e.Err)
}

func (e *UpdateError) Unwrap() error {
	return e.Err
}

func (e *DeleteError) Error() string {
	return fmt.Sprintf("failed to delete entity '%s' with id '%d': %v", e.Entity, e.ID, e.Err)
}

func (e *DeleteError) Unwrap() error {
	return e.Err
}

================
File: repository/tests/book_test.go
================
package repository

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/hoyci/book-store-api/repository"
	"github.com/hoyci/book-store-api/types"
	"github.com/lib/pq"
	"github.com/stretchr/testify/assert"
)

func TestCreateBook(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := repository.NewBookRepository(db)
	book := types.CreateBookPayload{
		Name:          "Go Programming",
		Description:   "A book about Go programming",
		Author:        "John Doe",
		Genres:        []string{"Programming"},
		ReleaseYear:   2024,
		NumberOfPages: 300,
		ImageUrl:      "http://example.com/go.jpg",
	}

	t.Run("successfully create book", func(t *testing.T) {
		mock.ExpectQuery("INSERT INTO books").
			WithArgs(book.Name, book.Description, book.Author, pq.Array(book.Genres), book.ReleaseYear, book.NumberOfPages, book.ImageUrl).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

		id, err := store.Create(context.Background(), book)

		assert.NoError(t, err)
		assert.Equal(t, int64(1), id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database execution error", func(t *testing.T) {
		mock.ExpectQuery("INSERT INTO books").
			WithArgs(book.Name, book.Description, book.Author, pq.Array(book.Genres), book.ReleaseYear, book.NumberOfPages, book.ImageUrl).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.Create(context.Background(), book)

		assert.Error(t, err)
		assert.Zero(t, id)
		assert.Contains(t, err.Error(), "failed to insert entity")

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestGetBookByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := repository.NewBookRepository(db)
	expectedCreatedAt := time.Date(2024, time.January, 1, 12, 0, 0, 0, time.UTC)

	t.Run("successfully get book by ID", func(t *testing.T) {
		mock.ExpectQuery("SELECT id, name, description, author, genres").
			WithArgs(1).
			WillReturnRows(sqlmock.NewRows([]string{"id", "name", "description", "author", "genres", "release_year", "number_of_pages", "image_url", "created_at"}).
				AddRow(1, "Go Programming", "A book about Go programming", "John Doe", pq.Array([]string{"Programming"}), 2024, 300, "http://example.com/go.jpg", expectedCreatedAt))

		book, err := store.GetByID(context.Background(), 1)
		assert.NoError(t, err)
		assert.NotNil(t, book)

		expectedID := int64(1)
		assert.Equal(t, expectedID, book.ID)
		assert.Equal(t, "Go Programming", book.Name)
		assert.Equal(t, expectedCreatedAt, book.CreatedAt)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database execution error", func(t *testing.T) {
		mock.ExpectQuery("SELECT id, name, description, author, genres").
			WithArgs(1).
			WillReturnError(fmt.Errorf("database connection error"))

		book, err := store.GetByID(context.Background(), 1)
		assert.Nil(t, book)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to fetch book by ID")

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("book not found", func(t *testing.T) {
		mock.ExpectQuery("SELECT id, name, description, author, genres").
			WithArgs(1).
			WillReturnRows(sqlmock.NewRows([]string{"id", "name", "description", "author", "genres", "release_year", "number_of_pages", "image_url", "created_at"})) // Nenhuma linha

		book, err := store.GetByID(context.Background(), 1)

		var notFoundErr *repository.ResourceNotFoundError
		assert.Nil(t, book)
		assert.Error(t, err)
		assert.True(t, errors.As(err, &notFoundErr))
		assert.Equal(t, 1, notFoundErr.ID)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestUpdateBook(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := repository.NewBookRepository(db)

	t.Run("successfully update book without NumberOfPages", func(t *testing.T) {
		updates := types.BookUpdatePayload{
			Name:        stringPtr("Updated Book Name"),
			Description: stringPtr("Updated Description"),
			Genres:      &[]string{"Updated Genre 1", "Updated Genre 2"},
			ReleaseYear: int32Ptr(2025),
		}

		// Ajuste o mock para refletir os campos enviados
		mock.ExpectExec("UPDATE books SET").
			WithArgs(
				"Updated Book Name",   // $1
				"Updated Description", // $2
				pq.Array([]string{"Updated Genre 1", "Updated Genre 2"}), // $3
				2025,     // $4
				int64(1), // $5
			).
			WillReturnResult(sqlmock.NewResult(1, 1))

		err := store.UpdateByID(context.Background(), 1, updates)

		assert.NoError(t, err)
		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	// t.Run("no fields to update", func(t *testing.T) {
	// 	emptyUpdates := types.BookUpdatePayload{}
	// 	err := store.Update(context.Background(), 1, emptyUpdates)

	// 	assert.NoError(t, err, "No error expected when no updates are provided")
	// 	if err := mock.ExpectationsWereMet(); err != nil {
	// 		t.Errorf("unmet expectations: %v", err)
	// 	}
	// })

	// t.Run("database execution error", func(t *testing.T) {
	// 	updates := types.BookUpdatePayload{
	// 		Name: stringPtr("Error Book"),
	// 	}

	// 	mock.ExpectExec("UPDATE books SET").
	// 		WithArgs("Error Book", int64(1)).
	// 		WillReturnError(fmt.Errorf("database error"))

	// 	err := store.Update(context.Background(), 1, updates)

	// 	assert.Error(t, err)
	// 	assert.Contains(t, err.Error(), "failed to update entity")
	// 	if err := mock.ExpectationsWereMet(); err != nil {
	// 		t.Errorf("unmet expectations: %v", err)
	// 	}
	// })
}

func TestDeleteByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := repository.NewBookRepository(db)

	t.Run("successfully delete book by ID", func(t *testing.T) {
		mock.ExpectQuery("UPDATE books SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

		id, err := store.DeleteByID(context.Background(), 1)
		expectedID := int64(1)

		assert.NoError(t, err)
		assert.Equal(t, expectedID, id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database execution error", func(t *testing.T) {
		mock.ExpectQuery("UPDATE books SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.DeleteByID(context.Background(), 1)

		assert.Error(t, err)
		assert.Equal(t, int64(0), id)

		var deleteErr *repository.DeleteError
		if assert.ErrorAs(t, err, &deleteErr) {
			assert.Contains(t, deleteErr.Error(), fmt.Sprintf("failed to delete entity 'book' with id '%d'", 1))
			assert.Contains(t, deleteErr.Error(), "database connection error")
		}

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

// Funções auxiliares para criar ponteiros
func stringPtr(s string) *string {
	return &s
}

func int32Ptr(i int32) *int32 {
	return &i
}

================
File: service/book_interface.go
================
package service

import (
	"context"

	"github.com/hoyci/book-store-api/types"
)

type BookServiceInterface interface {
	Create(ctx context.Context, payload types.CreateBookPayload) (int64, error)
	GetByID(ctx context.Context, id int) (*types.Book, error)
	DeleteByID(ctx context.Context, id int) error
}

================
File: service/book.go
================
package service

import (
	"context"

	"github.com/hoyci/book-store-api/repository"
	"github.com/hoyci/book-store-api/types"
)

type BookService struct {
	BookRepository repository.BookRepositoryInterface
}

func NewBookService(repo repository.BookRepositoryInterface) *BookService {
	return &BookService{BookRepository: repo}
}

func (s *BookService) Create(ctx context.Context, payload types.CreateBookPayload) (int64, error) {
	return s.BookRepository.Create(ctx, payload)
	// Here I can add send email when a user is created
}

func (s *BookService) GetByID(ctx context.Context, id int) (*types.Book, error) {
	return s.BookRepository.GetByID(ctx, id)
}

func (s *BookService) DeleteByID(ctx context.Context, id int) error {
	return s.BookRepository.DeleteByID(ctx, id)
	// Here I can add send email when a user is created
}

================
File: service/healthcheck_interface.go
================
package service

import (
	"context"

	"github.com/hoyci/book-store-api/types"
)

type HealthcheckServiceInterface interface {
	HandleHealthcheck(ctx context.Context) *types.HealthcheckResponse
}

================
File: service/healthcheck.go
================
package service

import (
	"context"

	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/types"
)

type HealthcheckService struct {
	Config config.Config
}

func NewHealthcheckService(cfg config.Config) *HealthcheckService {
	return &HealthcheckService{
		Config: cfg,
	}
}

func (s *HealthcheckService) HandleHealthcheck(ctx context.Context) *types.HealthcheckResponse {
	return &types.HealthcheckResponse{
		Status: "available",
		SystemInfo: map[string]string{
			"environment": s.Config.Environment,
		},
	}
}

================
File: service/tests/book_test.go
================
package service

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/hoyci/book-store-api/service"
	"github.com/hoyci/book-store-api/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockBookRepository struct {
	mock.Mock
}

func (m *MockBookRepository) Create(ctx context.Context, book types.CreateBookPayload) (int64, error) {
	args := m.Called(ctx, book)
	return args.Get(0).(int64), args.Error(1)
}

func (m *MockBookRepository) GetByID(ctx context.Context, id int) (*types.Book, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.Book), args.Error(1)
}

func (m *MockBookRepository) DeleteByID(ctx context.Context, id int) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

func TestCreate(t *testing.T) {
	mockRepo := new(MockBookRepository)
	bookService := service.NewBookService(mockRepo)

	payload := types.CreateBookPayload{
		Name:          "Test Book",
		Description:   "A great book",
		Author:        "John Doe",
		Genres:        []string{"Fiction"},
		ReleaseYear:   2024,
		NumberOfPages: 300,
		ImageUrl:      "http://example.com/book.jpg",
	}

	t.Run("successful book creation", func(t *testing.T) {
		mockRepo.On("Create", mock.Anything, payload).Once().Return(int64(1), nil)

		id, err := bookService.Create(context.Background(), payload)

		assert.NoError(t, err)
		assert.Equal(t, int64(1), id)
		mockRepo.AssertExpectations(t)
	})

	t.Run("repository error during creation", func(t *testing.T) {
		mockRepo.On("Create", mock.Anything, payload).Once().Return(int64(0), errors.New("repository error"))

		id, err := bookService.Create(context.Background(), payload)

		assert.Error(t, err)
		assert.Equal(t, int64(0), id)
		mockRepo.AssertExpectations(t)
	})
}

func TestGetByID(t *testing.T) {
	mockRepo := new(MockBookRepository)
	bookService := service.NewBookService(mockRepo)

	expectedBook := &types.Book{
		ID:            1,
		Name:          "Test Book",
		Description:   "A great book",
		Author:        "John Doe",
		Genres:        []string{"Fiction"},
		ReleaseYear:   2024,
		NumberOfPages: 300,
		ImageUrl:      "http://example.com/book.jpg",
		CreatedAt:     time.Now(),
	}

	t.Run("successful book retrieval", func(t *testing.T) {
		mockRepo.On("GetByID", mock.Anything, 1).Once().Return(expectedBook, nil)

		book, err := bookService.GetByID(context.Background(), 1)

		assert.NoError(t, err)
		assert.Equal(t, expectedBook, book)
		mockRepo.AssertExpectations(t)
	})

	t.Run("book not found", func(t *testing.T) {
		mockRepo.On("GetByID", mock.Anything, 2).Once().Return((*types.Book)(nil), errors.New("book not found"))

		book, err := bookService.GetByID(context.Background(), 2)

		assert.Error(t, err)
		assert.Nil(t, book)
		mockRepo.AssertExpectations(t)
	})

	t.Run("repository error during GetByID", func(t *testing.T) {
		mockRepo.On("GetByID", mock.Anything, 3).Once().Return((*types.Book)(nil), errors.New("repository error"))

		book, err := bookService.GetByID(context.Background(), 3)

		assert.Error(t, err)
		assert.Nil(t, book)
		mockRepo.AssertExpectations(t)
	})
}

func TestDeleteByID(t *testing.T) {
	mockRepo := new(MockBookRepository)
	bookService := service.NewBookService(mockRepo)

	t.Run("delete book successfully", func(t *testing.T) {
		mockRepo.On("DeleteByID", mock.Anything, 1).Once().Return(nil)

		err := bookService.DeleteByID(context.Background(), 1)

		assert.NoError(t, err)
		assert.Equal(t, err, nil)
		mockRepo.AssertExpectations(t)
	})

	t.Run("repository error during GetByID", func(t *testing.T) {
		mockRepo.On("DeleteByID", mock.Anything, 3).Once().Return(errors.New("repository error"))

		err := bookService.DeleteByID(context.Background(), 3)

		assert.Error(t, err)
		mockRepo.AssertExpectations(t)
	})
}

================
File: service/tests/healthcheck_test.go
================
package service

import (
	"context"
	"testing"

	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/service"
	"github.com/stretchr/testify/assert"
)

func TestHealthcheckProduction(t *testing.T) {
	mockConfig := config.Config{
		Environment: "production",
	}

	service := service.NewHealthcheckService(mockConfig)
	response := service.HandleHealthcheck(context.Background())
	assert.Equal(t, "available", response.Status)

	assert.Equal(t, "production", response.SystemInfo["environment"])
}

func TestHealthcheckDevelopment(t *testing.T) {
	mockConfig := config.Config{
		Environment: "development",
	}

	service := service.NewHealthcheckService(mockConfig)
	response := service.HandleHealthcheck(context.Background())
	assert.Equal(t, "available", response.Status)

	assert.Equal(t, "development", response.SystemInfo["environment"])
}

================
File: types/books.go
================
package types

import (
	"context"
	"time"
)

type BookRepository interface {
	Create(ctx context.Context, book Book) (int64, error)
	GetByID(ctx context.Context, id int) (*Book, error)
}

type Book struct {
	ID            int64      `json:"id"`
	Name          string     `json:"name"`
	Description   string     `json:"description"`
	Author        string     `json:"author"`
	Genres        []string   `json:"genres"`
	ReleaseYear   int32      `json:"releaseYear"`
	NumberOfPages int32      `json:"numberOfPages"`
	ImageUrl      string     `json:"imageUrl"`
	CreatedAt     time.Time  `json:"createdAt"`
	DeletedAt     *time.Time `json:"deletedAt"`
}

type CreateBookPayload struct {
	Name          string   `json:"name" validate:"required"`
	Description   string   `json:"description" validate:"required"`
	Author        string   `json:"author" validate:"required"`
	Genres        []string `json:"genres" validate:"required"`
	ReleaseYear   int32    `json:"releaseYear" validate:"required"`
	NumberOfPages int32    `json:"numberOfPages" validate:"required"`
	ImageUrl      string   `json:"imageUrl" validate:"required"`
}

type BookUpdatePayload struct {
	Name          *string   `json:"name"`
	Description   *string   `json:"description"`
	Author        *string   `json:"author"`
	Genres        *[]string `json:"genres"`
	ReleaseYear   *int32    `json:"releaseYear"`
	NumberOfPages *int32    `json:"numberOfPages"`
	ImageUrl      *string   `json:"imageUrl"`
}

================
File: types/healthcheck.go
================
package types

type HealthcheckResponse struct {
	Status     string            `json:"status"`
	SystemInfo map[string]string `json:"system_info"`
}

================
File: utils/utils.go
================
package utils

import (
	"encoding/json"
	"fmt"
	"net/http"
)

func ParseJSON(r *http.Request, payload any) error {
	if r.Body == nil {
		return fmt.Errorf("missing request body")
	}

	return json.NewDecoder(r.Body).Decode(payload)
}

func WriteJSON(w http.ResponseWriter, status int, v any) error {
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(status)
	return json.NewEncoder(w).Encode(v)
}

func WriteError(w http.ResponseWriter, status int, err error) {
	WriteJSON(
		w,
		status,
		map[string]string{
			"error": err.Error(),
		},
	)
}
