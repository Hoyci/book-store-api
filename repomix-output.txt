This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-17T21:25:28.032Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.air.toml
.gitignore
cmd/api/api.go
cmd/main.go
cmd/migrate/main.go
cmd/migrate/migrations/20241202144458_add-book-table.down.sql
cmd/migrate/migrations/20241202144458_add-book-table.up.sql
cmd/migrate/migrations/20250109113845_add-refresh-token-table.down.sql
cmd/migrate/migrations/20250109113845_add-refresh-token-table.up.sql
cmd/migrate/migrations/20250112193042_add-user-table.down.sql
cmd/migrate/migrations/20250112193042_add-user-table.up.sql
config/env.go
db/db.go
docker-compose.yml
go.mod
go.sum
Makefile
service/auth/routes_test.go
service/auth/routes.go
service/auth/store_test.go
service/auth/store.go
service/book/routes_test.go
service/book/routes.go
service/book/store_test.go
service/book/store.go
service/healthcheck/routes_test.go
service/healthcheck/routes.go
service/user/routes_test.go
service/user/routes.go
service/user/store_test.go
service/user/store.go
types/api.go
types/auth.go
types/book.go
types/healthcheck.go
types/user.go
types/uuid.go
utils/json.go
utils/jwt.go
utils/logger.go
utils/password.go
utils/utils.go
utils/uuid.go

================================================================
Repository Files
================================================================

================
File: .air.toml
================
root = "."
tmp_dir = "tmp"

[build]
  cmd = "go build -o ./tmp/main.exe cmd/main.go"
  bin = "./tmp/main.exe"
  delay = 1000
  include_ext = ["go"]
  exclude_dir = ["tmp", "vendor"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  log = "air.log"
  include_dir = []

[log]
  timestamps = true

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"


# [build]
#   cmd = "go build -o ./tmp/main.exe cmd/main.go"
#   bin = "./tmp/main.exe"
#   delay = 1000
#   exclude_dir = ["assets", "tmp", "vendor", "testdata"]
#   exclude_file = []
#   exclude_regex = ["_test.go"]
#   exclude_unchanged = false
#   follow_symlink = false
#   full_bin = ""
#   include_dir = []
#   include_ext = ["go", "tpl", "tmpl", "html"]
#   kill_delay = "0s"
#   log = "build-errors.log"
#   send_interrupt = false
#   stop_on_error = true

# [color]
#   app = ""
#   build = "yellow"
#   main = "magenta"
#   runner = "green"
#   watcher = "cyan"

# [log]
#   time = false

# [misc]
#   clean_on_exit = false

# [screen]
#   clear_on_rebuild = false

================
File: .gitignore
================
tmp

================
File: cmd/api/api.go
================
package api

import (
	"database/sql"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/service/auth"
	"github.com/hoyci/book-store-api/service/book"
	"github.com/hoyci/book-store-api/service/healthcheck"
	"github.com/hoyci/book-store-api/service/user"
	"github.com/hoyci/book-store-api/utils"
)

type APIServer struct {
	addr   string
	db     *sql.DB
	Router *mux.Router
	Config config.Config
}

func NewApiServer(addr string, db *sql.DB) *APIServer {
	return &APIServer{
		addr:   addr,
		db:     db,
		Router: nil,
		Config: config.Envs,
	}
}

func (s *APIServer) SetupRouter(
	healthCheckHandler *healthcheck.HealthCheckHandler,
	bookHandler *book.BookHandler,
	userHandler *user.UserHandler,
	authHandler *auth.AuthHandler,
) *mux.Router {
	utils.InitLogger()
	router := mux.NewRouter()

	router.Use(utils.LoggingMiddleware)

	subrouter := router.PathPrefix("/api/v1").Subrouter()

	subrouter.HandleFunc("/healthcheck", healthCheckHandler.HandleHealthCheck).Methods(http.MethodGet)

	subrouter.HandleFunc("/auth", authHandler.HandleUserLogin).Methods(http.MethodPost)
	subrouter.HandleFunc("/auth/refresh", authHandler.HandleRefreshToken).Methods(http.MethodPost)

	subrouter.HandleFunc("/books", bookHandler.HandleCreateBook).Methods(http.MethodPost)
	subrouter.HandleFunc("/books/{id}", bookHandler.HandleGetBookByID).Methods(http.MethodGet)
	subrouter.HandleFunc("/books/{id}", bookHandler.HandleUpdateBookByID).Methods(http.MethodPut)
	subrouter.HandleFunc("/books/{id}", bookHandler.HandleDeleteBookByID).Methods(http.MethodDelete)

	subrouter.HandleFunc("/users", userHandler.HandleCreateUser).Methods(http.MethodPost)
	subrouter.HandleFunc("/users/{id}", userHandler.HandleGetUserByID).Methods(http.MethodGet)
	subrouter.HandleFunc("/users/{id}", userHandler.HandleUpdateUserByID).Methods(http.MethodPut)
	subrouter.HandleFunc("/users/{id}", userHandler.HandleDeleteUserByID).Methods(http.MethodDelete)

	s.Router = router

	return router
}

func (s *APIServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.Router.ServeHTTP(w, r)
}

================
File: cmd/main.go
================
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/db"
	"github.com/hoyci/book-store-api/service/auth"
	"github.com/hoyci/book-store-api/service/book"
	"github.com/hoyci/book-store-api/service/healthcheck"
	"github.com/hoyci/book-store-api/service/user"
	"github.com/hoyci/book-store-api/utils"
)

func main() {
	db := db.NewPGStorage()
	path := fmt.Sprintf("127.0.0.1:%s", config.Envs.Port)

	apiServer := api.NewApiServer(path, db)

	healthCheckHandler := healthcheck.NewHealthCheckHandler(config.Envs)

	bookStore := book.NewBookStore(db)
	bookHandler := book.NewBookHandler(bookStore)

	userStore := user.NewUserStore(db)
	userHandler := user.NewUserHandler(userStore)

	authStore := auth.NewAuthStore(db)
	uuidGen := &utils.UUIDGeneratorUtil{}
	authHandler := auth.NewAuthHandler(userStore, authStore, uuidGen)

	apiServer.SetupRouter(healthCheckHandler, bookHandler, userHandler, authHandler)

	log.Println("Listening on:", path)
	http.ListenAndServe(path, apiServer.Router)
}

// TODO: Adicionar os endpoints privados
// TODO: Adicionar restrição nos endpoints de usuários e books (somente o proprio usuário pode alterar e deletar suas informações) / (somente o proprio usuário pode alterar e deletar informações dos seus livros)
// TODO: Adicionar swagger para documentar a API
// TODO: Deve ser possível que o usuário atribua um livro a ele (Criar um projeto tipo o Skoob)
// TODO: Endpoints de DELETE devem retornar status NoContent

================
File: cmd/migrate/main.go
================
package main

import (
	"database/sql"
	"log"
	"os"

	"github.com/golang-migrate/migrate/v4"
	pgMigrate "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"github.com/hoyci/book-store-api/config"
	_ "github.com/lib/pq"
)

func main() {
	db, err := sql.Open("postgres", config.Envs.DatabaseURL)
	if err != nil {
		log.Fatalf("Failed to connect to the database: %v", err)
	}
	defer db.Close()

	driver, err := pgMigrate.WithInstance(db, &pgMigrate.Config{})
	if err != nil {
		log.Fatalf("Error creating migrate driver: %v", err)
	}

	m, err := migrate.NewWithDatabaseInstance(
		"file://cmd/migrate/migrations",
		"public",
		driver,
	)
	if err != nil {
		log.Fatalf("Error creating migrate instance: %v", err)
	}

	cmd := os.Args[len(os.Args)-1]
	switch cmd {
	case "up":
		if err := m.Up(); err != nil && err != migrate.ErrNoChange {
			log.Fatalf("Migration up failed: %v", err)
		}
		log.Println("Migrations applied successfully.")
	case "down":
		if err := m.Down(); err != nil && err != migrate.ErrNoChange {
			log.Fatalf("Migration down failed: %v", err)
		}
		log.Println("Migrations reverted successfully.")
	default:
		log.Println("No command provided. Use 'up' or 'down'.")
	}
}

================
File: cmd/migrate/migrations/20241202144458_add-book-table.down.sql
================
DROP TABLE books;

================
File: cmd/migrate/migrations/20241202144458_add-book-table.up.sql
================
CREATE TABLE IF NOT EXISTS books (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,     
    author VARCHAR(255),   
    genres TEXT[],         
    release_year INT,      
    number_of_pages INT,    
    image_url VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP
);

================
File: cmd/migrate/migrations/20250109113845_add-refresh-token-table.down.sql
================
DROP TABLE refresh_tokens;

================
File: cmd/migrate/migrations/20250109113845_add-refresh-token-table.up.sql
================
CREATE TABLE refresh_tokens (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL UNIQUE,
    jti VARCHAR(36) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

================
File: cmd/migrate/migrations/20250112193042_add-user-table.down.sql
================
DROP TABLE users;

================
File: cmd/migrate/migrations/20250112193042_add-user-table.up.sql
================
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,   
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP
);

================
File: config/env.go
================
package config

import (
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

type Config struct {
	Port                   string
	Environment            string
	DatabaseURL            string
	JWTSecret              string
	JWTExpirationInSeconds int64
}

var Envs = initConfig()

func initConfig() Config {
	godotenv.Load()

	return Config{
		Port:                   getEnv("PORT", "8080"),
		Environment:            getEnv("ENV", "development"),
		DatabaseURL:            getEnv("DATABASE_URL", "postgresql://user:password@localhost:5432/postgres?sslmode=disable"),
		JWTSecret:              getEnv("SECRET_KEY", "ABRACADABARA"),
		JWTExpirationInSeconds: getEnvAsInt("JWT_EXP", 3600*24*7),
	}
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}

	return fallback
}

func getEnvAsInt(key string, fallback int64) int64 {
	if value, ok := os.LookupEnv(key); ok {
		i, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return fallback
		}

		return i
	}

	return fallback
}

================
File: db/db.go
================
package db

import (
	"database/sql"
	"log"

	"github.com/hoyci/book-store-api/config"
	_ "github.com/lib/pq"
)

func NewPGStorage() *sql.DB {
	db, err := sql.Open("postgres", config.Envs.DatabaseURL)
	if err != nil {
		log.Fatalf("Failed to open database connection: %v", err)
	}

	return db
}

================
File: docker-compose.yml
================
services:
  db:
    image: bitnami/postgresql:latest
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: postgres
    ports:
      - "5432:5432"
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:

================
File: go.mod
================
module github.com/hoyci/book-store-api

go 1.23.1

require (
	github.com/golang-migrate/migrate/v4 v4.18.1
	github.com/joho/godotenv v1.5.1
	github.com/stretchr/testify v1.9.0
	golang.org/x/crypto v0.27.0
)

require (
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/kr/pretty v0.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	go.uber.org/atomic v1.11.0 // indirect
	golang.org/x/net v0.29.0 // indirect
	golang.org/x/sys v0.25.0 // indirect
	golang.org/x/text v0.18.0 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
)

require (
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/go-playground/validator/v10 v10.23.0
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/uuid v1.6.0
	github.com/gorilla/mux v1.8.1
	github.com/lib/pq v1.10.9
	github.com/pmezard/go-difflib v1.0.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: go.sum
================
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 h1:L/gRVlceqvL25UVaW/CKtUDjefjrs0SPonmDGUVOYP0=
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/DATA-DOG/go-sqlmock v1.5.2 h1:OcvFkGmslmlZibjAjaHm3L//6LiuBgolP7OputlJIzU=
github.com/DATA-DOG/go-sqlmock v1.5.2/go.mod h1:88MAG/4G7SMwSE3CeA0ZKzrT5CiOU3OJ+JlNzwDqpNU=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dhui/dktest v0.4.3 h1:wquqUxAFdcUgabAVLvSCOKOlag5cIZuaOjYIBOWdsR0=
github.com/dhui/dktest v0.4.3/go.mod h1:zNK8IwktWzQRm6I/l2Wjp7MakiyaFWv4G1hjmodmMTs=
github.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/docker/docker v27.2.0+incompatible h1:Rk9nIVdfH3+Vz4cyI/uhbINhEZ/oLmc+CBXmH6fbNk4=
github.com/docker/docker v27.2.0+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.23.0 h1:/PwmTwZhS0dPkav3cdK9kV1FsAmrL8sThn8IHr/sO+o=
github.com/go-playground/validator/v10 v10.23.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/golang-migrate/migrate/v4 v4.18.1 h1:JML/k+t4tpHCpQTCAD62Nu43NUFzHY4CV3uAuvHGC+Y=
github.com/golang-migrate/migrate/v4 v4.18.1/go.mod h1:HAX6m3sQgcdO81tdjn5exv20+3Kb13cmGli1hrD6hks=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=
github.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=
github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=
github.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=
github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46/go.mod h1:yyMNCyc/Ib3bDTKd379tNMpB/7/H5TjM2Y9QJ5THLbE=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
github.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=
github.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 h1:TT4fX+nBOA/+LUkobKGW1ydGcn+G3vRw9+g5HwCphpk=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0/go.mod h1:L7UH0GbB0p47T4Rri3uHjbpCFYrVrwc1I25QhNPiGK8=
go.opentelemetry.io/otel v1.29.0 h1:PdomN/Al4q/lN6iBJEN3AwPvUiHPMlt93c8bqTG5Llw=
go.opentelemetry.io/otel v1.29.0/go.mod h1:N/WtXPs1CNCUEx+Agz5uouwCba+i+bJGFicT8SR4NP8=
go.opentelemetry.io/otel/metric v1.29.0 h1:vPf/HFWTNkPu1aYeIsc98l4ktOQaL6LeSoeV2g+8YLc=
go.opentelemetry.io/otel/metric v1.29.0/go.mod h1:auu/QWieFVWx+DmQOUMgj0F8LHWdgalxXqvp7BII/W8=
go.opentelemetry.io/otel/trace v1.29.0 h1:J/8ZNK4XgR7a21DZUAsbF8pZ5Jcw1VhACmnYt39JTi4=
go.opentelemetry.io/otel/trace v1.29.0/go.mod h1:eHl3w0sp3paPkYstJOmAimxhiFXPg+MMTlEh3nsQgWQ=
go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
golang.org/x/crypto v0.27.0 h1:GXm2NjJrPaiv/h1tb2UH8QfgC/hOf/+z0p6PT8o1w7A=
golang.org/x/crypto v0.27.0/go.mod h1:1Xngt8kV6Dvbssa53Ziq6Eqn0HqbZi5Z6R0ZpwQzt70=
golang.org/x/net v0.29.0 h1:5ORfpBpCs4HzDYoodCDBbwHzdR5UrLBZ3sOnUJmFoHo=
golang.org/x/net v0.29.0/go.mod h1:gLkgy8jTGERgjzMic6DS9+SP0ajcu6Xu3Orq/SpETg0=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=
golang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

================
File: Makefile
================
build:
	@go build -o bin/ecom cmd/main.go

test:
	@go test -v ./...

run: build
	@./bin/ecom

# migrate create -ext sql -dir cmd/migrate/migrations add-user-table
migration:
	@migration create -ext sql -dir cmd/migrate/migrations $(filter-out $@,$(MAKECMDGOALS))

# go run cmd/migrate/main.go up
@migrate-up:
	@go run cmd/migrate/main.go up

# go run cmd/migrate/main.go down
@migrate-down:
	@go run cmd/migrate/main.go down

dev:
	@if [ "$(ENV)" = "development" ]; then air; else echo "Use the run command for production"; fi

================
File: service/auth/routes_test.go
================
package auth_test

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/service/auth"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockUUIDGenerator struct {
	mock.Mock
}

func (m *MockUUIDGenerator) New() string {
	args := m.Called()
	return args.String(0)
}

type MockAuthStore struct {
	mock.Mock
}

func (m *MockAuthStore) GetRefreshTokenByUserID(ctx context.Context, userID int) (*types.RefreshToken, error) {
	args := m.Called(ctx, userID)
	return args.Get(0).(*types.RefreshToken), args.Error(1)
}

func (m *MockAuthStore) UpsertRefreshToken(ctx context.Context, payload types.UpdateRefreshTokenPayload) error {
	args := m.Called(ctx, payload)
	return args.Error(0)
}

type MockUserStore struct {
	mock.Mock
}

func (m *MockUserStore) Create(ctx context.Context, user types.CreateUserDatabasePayload) (*types.UserResponse, error) {
	args := m.Called(ctx, user)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) GetByID(ctx context.Context, id int) (*types.UserResponse, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) GetByEmail(ctx context.Context, email string) (*types.UserResponse, error) {
	args := m.Called(ctx, email)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) UpdateByID(ctx context.Context, id int, newUser types.UpdateUserPayload) (*types.UserResponse, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) DeleteByID(ctx context.Context, id int) (int, error) {
	args := m.Called(ctx, id)
	if val, ok := args.Get(0).(int); ok {
		return val, args.Error(1)
	}
	return 0, args.Error(1)
}

func TestHandleUserLogin(t *testing.T) {
	setupTestServer := func() (*MockUserStore, *MockAuthStore, *MockUUIDGenerator, *httptest.Server, *mux.Router, config.Config) {
		mockUUID := new(MockUUIDGenerator)
		mockAuthStore := new(MockAuthStore)
		mockUserStore := new(MockUserStore)
		mockAuthHandler := auth.NewAuthHandler(mockUserStore, mockAuthStore, mockUUID)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, nil, nil, mockAuthHandler)
		ts := httptest.NewServer(router)
		return mockUserStore, mockAuthStore, mockUUID, ts, router, apiServer.Config
	}

	t.Run("it should throw an error when body is not a valid JSON", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		invalidBody := bytes.NewReader([]byte("INVALID JSON"))
		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", invalidBody)
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Body is not a valid json"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is a valid JSON but missing key", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.UserLoginPayload{}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Email' is invalid: required", "Field 'Password' is invalid: required"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body does not contain a valid email", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.UserLoginPayload{
			Email:    "johndoe",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Email' is invalid: email"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when password or confirmPassword is smaller than 8 chars", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "12345",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Password' is invalid: min"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent user ID", func(t *testing.T) {
		mockUserStore, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("GetByEmail", mock.Anything, mock.Anything).Return((*types.UserResponse)(nil), sql.ErrNoRows)

		payload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, _ := io.ReadAll(res.Body)
		expected := `{"error": "No user found with email johndoe@email.com"}`
		assert.JSONEq(t, expected, string(responseBody))
	})

	t.Run("it should throw a database find error", func(t *testing.T) {
		mockUserStore, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("GetByEmail", mock.Anything, mock.Anything).Return((*types.UserResponse)(nil), fmt.Errorf("no row found with email: 'johndoe@email.com'"))

		payload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusInternalServerError, res.StatusCode)

		responseBody, _ := io.ReadAll(res.Body)
		expected := `{"error":"An unexpected error occurred"}`
		assert.JSONEq(t, expected, string(responseBody))
	})

	t.Run("it should successfully authenticate a user", func(t *testing.T) {
		mockUserStore, mockAuthStore, mockUUID, ts, router, config := setupTestServer()
		defer ts.Close()

		mockUUID.On("New").Return("mocked-uuid")

		mockUserStore.On("GetByEmail", mock.Anything, mock.Anything).Return(
			&types.UserResponse{
				ID:        1,
				Username:  "JohnDoe",
				Email:     "johndoe@email.com",
				CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
				UpdatedAt: nil,
				DeletedAt: nil,
			},
			nil,
		)

		mockAuthStore.On("UpsertRefreshToken", mock.Anything, mock.Anything).Return(nil)

		payload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		var responseMap map[string]interface{}
		err = json.Unmarshal(responseBody, &responseMap)
		if err != nil {
			t.Fatalf("Failed to unmarshal response body: %v", err)
		}

		access_token, ok := responseMap["access_token"].(string)
		if !ok {
			t.Fatalf("access_token not found or not a string")
		}

		refresh_token, ok := responseMap["refresh_token"].(string)
		if !ok {
			t.Fatalf("refresh_token not found or not a string")
		}

		access_token_claims, err := utils.VerifyJWT(access_token, config.JWTSecret)
		assert.NoError(t, err, "Failed to verify JWT token")

		assert.Equal(t, "johndoe@email.com", access_token_claims.Email, "Email claim mismatch")
		assert.Equal(t, "JohnDoe", access_token_claims.Username, "Username claim mismatch")
		assert.Equal(t, 1, access_token_claims.UserID, "UserID claim mismatch")

		refresh_token_claims, err := utils.VerifyJWT(refresh_token, config.JWTSecret)
		assert.NoError(t, err, "Failed to verify JWT token")

		assert.Equal(t, 1, refresh_token_claims.UserID, "UserID claim mismatch")
	})
}

func TestHandleRefreshToken(t *testing.T) {
	setupTestServer := func() (*MockUserStore, *MockAuthStore, *MockUUIDGenerator, *httptest.Server, *mux.Router, config.Config) {
		mockUUID := new(MockUUIDGenerator)
		mockAuthStore := new(MockAuthStore)
		mockUserStore := new(MockUserStore)
		mockAuthHandler := auth.NewAuthHandler(mockUserStore, mockAuthStore, mockUUID)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, nil, nil, mockAuthHandler)
		ts := httptest.NewServer(router)
		return mockUserStore, mockAuthStore, mockUUID, ts, router, apiServer.Config
	}

	t.Run("it should throw an error when body is not a valid JSON", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		invalidBody := bytes.NewReader([]byte("INVALID JSON"))
		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", invalidBody)
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Body is not a valid json"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is a valid JSON but missing key", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.UserLoginPayload{}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'RefreshToken' is invalid: required"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body does not contain a valid token", func(t *testing.T) {
		_, _, _, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.RefreshTokenPayload{
			RefreshToken: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusUnauthorized, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Refresh token is invalid or has been expired"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should successfully refresh user token", func(t *testing.T) {
		mockUserStore, mockAuthStore, mockUUID, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUUID.On("New").Return("mocked-uuid")

		mockUserStore.On("GetByEmail", mock.Anything, mock.Anything).Return(
			&types.UserResponse{
				ID:        1,
				Username:  "JohnDoe",
				Email:     "johndoe@email.com",
				CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
				UpdatedAt: nil,
				DeletedAt: nil,
			},
			nil,
		)

		mockAuthStore.On("GetRefreshTokenByUserID", mock.Anything, mock.Anything).Return(&types.RefreshToken{}, sql.ErrNoRows)

		mockAuthStore.On("UpsertRefreshToken", mock.Anything, mock.Anything).Return(nil)

		userLoginPayload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(userLoginPayload)

		userLoginReq := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		userLoginW := httptest.NewRecorder()

		router.ServeHTTP(userLoginW, userLoginReq)

		resUserLogin := userLoginW.Result()
		defer resUserLogin.Body.Close()

		assert.Equal(t, http.StatusOK, resUserLogin.StatusCode)

		responseUserLoginBody, err := io.ReadAll(resUserLogin.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		var responseUserLoginMap types.UserLoginResponse
		err = json.Unmarshal(responseUserLoginBody, &responseUserLoginMap)
		if err != nil {
			t.Fatalf("Failed to unmarshal response body: %v", err)
		}

		assert.NotEmpty(t, responseUserLoginMap.AccessToken, "Access token should not be empty")
		assert.NotEmpty(t, responseUserLoginMap.RefreshToken, "Refresh token should not be empty")

		userRefreshTokenPayload := types.RefreshTokenPayload{
			RefreshToken: responseUserLoginMap.RefreshToken,
		}
		userRefreshTokenMarshalled, _ := json.Marshal(userRefreshTokenPayload)

		reqRefreshToken := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", bytes.NewBuffer(userRefreshTokenMarshalled))
		wRefreshToken := httptest.NewRecorder()

		router.ServeHTTP(wRefreshToken, reqRefreshToken)

		resRefreshToken := wRefreshToken.Result()
		defer resRefreshToken.Body.Close()

		assert.Equal(t, http.StatusNotFound, resRefreshToken.StatusCode)

		responseBody, err := io.ReadAll(resRefreshToken.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No refresh token found with user ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should successfully refresh user token", func(t *testing.T) {
		mockUserStore, mockAuthStore, mockUUID, ts, router, config := setupTestServer()
		defer ts.Close()

		mockUUID.On("New").Return("mocked-uuid")

		mockUserStore.On("GetByEmail", mock.Anything, mock.Anything).Return(
			&types.UserResponse{
				ID:        1,
				Username:  "JohnDoe",
				Email:     "johndoe@email.com",
				CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
				UpdatedAt: nil,
				DeletedAt: nil,
			},
			nil,
		)

		mockAuthStore.On("GetRefreshTokenByUserID", mock.Anything, mock.Anything).Return(
			&types.RefreshToken{
				ID:        1,
				UserID:    1,
				CreatedAt: time.Now(),
				ExpiresAt: time.Now().Add(24 * time.Hour),
				Jti:       "mocked-uuid",
			},
			nil,
		)

		mockAuthStore.On("UpsertRefreshToken", mock.Anything, mock.Anything).Return(nil)

		userLoginPayload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(userLoginPayload)

		userLoginReq := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		userLoginW := httptest.NewRecorder()

		router.ServeHTTP(userLoginW, userLoginReq)

		resUserLogin := userLoginW.Result()
		defer resUserLogin.Body.Close()

		assert.Equal(t, http.StatusOK, resUserLogin.StatusCode)

		responseUserLoginBody, err := io.ReadAll(resUserLogin.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		var responseUserLoginMap types.UserLoginResponse
		err = json.Unmarshal(responseUserLoginBody, &responseUserLoginMap)
		if err != nil {
			t.Fatalf("Failed to unmarshal response body: %v", err)
		}

		assert.NotEmpty(t, responseUserLoginMap.AccessToken, "Access token should not be empty")
		assert.NotEmpty(t, responseUserLoginMap.RefreshToken, "Refresh token should not be empty")

		userRefreshTokenPayload := types.RefreshTokenPayload{
			RefreshToken: responseUserLoginMap.RefreshToken,
		}
		userRefreshTokenMarshalled, _ := json.Marshal(userRefreshTokenPayload)

		reqRefreshToken := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", bytes.NewBuffer(userRefreshTokenMarshalled))
		wRefreshToken := httptest.NewRecorder()

		router.ServeHTTP(wRefreshToken, reqRefreshToken)

		resRefreshToken := wRefreshToken.Result()
		defer resRefreshToken.Body.Close()

		assert.Equal(t, http.StatusOK, resRefreshToken.StatusCode)

		responseRefreshTokenBody, err := io.ReadAll(resRefreshToken.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		var responseRefreshTokenMap map[string]interface{}
		err = json.Unmarshal(responseRefreshTokenBody, &responseRefreshTokenMap)
		if err != nil {
			t.Fatalf("Failed to unmarshal response body: %v", err)
		}

		access_token, ok := responseRefreshTokenMap["access_token"].(string)
		if !ok {
			t.Fatalf("access_token not found or not a string")
		}

		refresh_token, ok := responseRefreshTokenMap["refresh_token"].(string)
		if !ok {
			t.Fatalf("refresh_token not found or not a string")
		}

		access_token_claims, err := utils.VerifyJWT(access_token, config.JWTSecret)
		assert.NoError(t, err, "Failed to verify JWT token")

		assert.Equal(t, "johndoe@email.com", access_token_claims.Email, "Email claim mismatch")
		assert.Equal(t, "JohnDoe", access_token_claims.Username, "Username claim mismatch")
		assert.Equal(t, 1, access_token_claims.UserID, "UserID claim mismatch")

		refresh_token_claims, err := utils.VerifyJWT(refresh_token, config.JWTSecret)
		assert.NoError(t, err, "Failed to verify JWT token")
		assert.Equal(t, 1, refresh_token_claims.UserID, "UserID claim mismatch")
	})

	t.Run("it should not be able refresh user with expired token", func(t *testing.T) {
		mockUserStore, mockAuthStore, mockUUID, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUUID.On("New").Return("mocked-uuid")

		mockUserStore.On("GetByEmail", mock.Anything, mock.Anything).Return(
			&types.UserResponse{
				ID:        1,
				Username:  "JohnDoe",
				Email:     "johndoe@email.com",
				CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
				UpdatedAt: nil,
				DeletedAt: nil,
			},
			nil,
		)

		mockAuthStore.On("GetRefreshTokenByUserID", mock.Anything, mock.Anything).Return(
			&types.RefreshToken{
				ID:        1,
				UserID:    1,
				CreatedAt: time.Now(),
				ExpiresAt: time.Now().Add(24 * time.Hour),
				Jti:       "mocked-uuid",
			},
			nil,
		).Once()

		mockAuthStore.On("UpsertRefreshToken", mock.Anything, mock.Anything).Return(nil)

		userLoginPayload := types.UserLoginPayload{
			Email:    "johndoe@email.com",
			Password: "123mudar",
		}
		marshalled, _ := json.Marshal(userLoginPayload)

		userLoginReq := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth", bytes.NewBuffer(marshalled))
		userLoginW := httptest.NewRecorder()

		router.ServeHTTP(userLoginW, userLoginReq)

		resUserLogin := userLoginW.Result()
		defer resUserLogin.Body.Close()

		assert.Equal(t, http.StatusOK, resUserLogin.StatusCode)

		responseUserLoginBody, err := io.ReadAll(resUserLogin.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		var responseUserLoginMap types.UserLoginResponse
		err = json.Unmarshal(responseUserLoginBody, &responseUserLoginMap)
		if err != nil {
			t.Fatalf("Failed to unmarshal response body: %v", err)
		}

		assert.NotEmpty(t, responseUserLoginMap.AccessToken, "Access token should not be empty")
		assert.NotEmpty(t, responseUserLoginMap.RefreshToken, "Refresh token should not be empty")

		userRefreshTokenPayload := types.RefreshTokenPayload{
			RefreshToken: responseUserLoginMap.RefreshToken,
		}
		userRefreshTokenMarshalled, _ := json.Marshal(userRefreshTokenPayload)

		reqRefreshToken1 := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", bytes.NewBuffer(userRefreshTokenMarshalled))
		wRefreshToken1 := httptest.NewRecorder()

		router.ServeHTTP(wRefreshToken1, reqRefreshToken1)

		resRefreshToken1 := wRefreshToken1.Result()
		defer resRefreshToken1.Body.Close()

		assert.Equal(t, http.StatusOK, resRefreshToken1.StatusCode)

		mockAuthStore.On("GetRefreshTokenByUserID", mock.Anything, mock.Anything).Return(
			&types.RefreshToken{
				ID:        1,
				UserID:    1,
				CreatedAt: time.Now(),
				ExpiresAt: time.Now().Add(24 * time.Hour),
				Jti:       "mocked-uuid2",
			},
			nil,
		).Once()

		reqRefreshToken2 := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/auth/refresh", bytes.NewBuffer(userRefreshTokenMarshalled))
		wRefreshToken2 := httptest.NewRecorder()

		router.ServeHTTP(wRefreshToken2, reqRefreshToken2)

		resRefreshToken2 := wRefreshToken2.Result()
		defer resRefreshToken2.Body.Close()

		assert.Equal(t, http.StatusUnauthorized, resRefreshToken2.StatusCode)
	})
}

================
File: service/auth/routes.go
================
package auth

import (
	"database/sql"
	"fmt"
	"net/http"

	"github.com/go-playground/validator/v10"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
)

var validate = validator.New()

type AuthHandler struct {
	userStore types.UserStore
	authStore types.AuthStore
	UUIDGen   types.UUIDGenerator
}

func NewAuthHandler(
	userStore types.UserStore,
	authStore types.AuthStore,
	UUIDGen types.UUIDGenerator,
) *AuthHandler {
	return &AuthHandler{
		userStore: userStore,
		authStore: authStore,
		UUIDGen:   UUIDGen,
	}
}

func (h *AuthHandler) HandleUserLogin(w http.ResponseWriter, r *http.Request) {
	var requestPayload types.UserLoginPayload
	if err := utils.ParseJSON(r, &requestPayload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleUserLogin", "User sent request with an invalid JSON", "Body is not a valid json")
		return
	}

	if err := validate.Struct(requestPayload); err != nil {
		var errorMessages []string
		for _, e := range err.(validator.ValidationErrors) {
			errorMessages = append(errorMessages, fmt.Sprintf("Field '%s' is invalid: %s", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, err, "HandleUserLogin", "User sent a request containing JSON with information outside the permitted format", errorMessages)
		return
	}

	user, err := h.userStore.GetByEmail(r.Context(), requestPayload.Email)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleUserLogin", "Failed to get user by email from database", fmt.Sprintf("No user found with email %s", requestPayload.Email))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "Failed get user by email from database", "An unexpected error occurred")
		return
	}

	accessToken, err := utils.CreateJWT(user.ID, user.Username, user.Email, config.Envs.JWTSecret, 3600, h.UUIDGen)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "An error occured during the create JWT process", "An unexpected error occurred")
	}

	refreshToken, err := utils.CreateJWT(user.ID, user.Username, user.Email, config.Envs.JWTSecret, config.Envs.JWTExpirationInSeconds, h.UUIDGen)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "An error occured during the create JWT process", "An unexpected error occurred")
	}

	refreshTokenClaims, err := utils.VerifyJWT(refreshToken, config.Envs.JWTSecret)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "Failed to parse the new refresh token", "An unexpected error occurred")
		return
	}

	err = h.authStore.UpsertRefreshToken(
		r.Context(),
		types.UpdateRefreshTokenPayload{
			UserID:    refreshTokenClaims.UserID,
			Jti:       refreshTokenClaims.RegisteredClaims.ID,
			ExpiresAt: refreshTokenClaims.RegisteredClaims.ExpiresAt.Time,
		},
	)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "Failed to insert refresh token", "Internal Server Error")
		return
	}

	utils.WriteJSON(w, http.StatusOK, types.UserLoginResponse{AccessToken: accessToken, RefreshToken: refreshToken})
}

func (h *AuthHandler) HandleRefreshToken(w http.ResponseWriter, r *http.Request) {
	var requestPayload types.RefreshTokenPayload
	if err := utils.ParseJSON(r, &requestPayload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleUserLogin", "User sent request with an invalid JSON", "Body is not a valid json")
		return
	}

	if err := validate.Struct(requestPayload); err != nil {
		var errorMessages []string
		for _, e := range err.(validator.ValidationErrors) {
			errorMessages = append(errorMessages, fmt.Sprintf("Field '%s' is invalid: %s", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, err, "HandleUserLogin", "User sent a request containing JSON with information outside the permitted format", errorMessages)
		return
	}

	claims, err := utils.VerifyJWT(requestPayload.RefreshToken, config.Envs.JWTSecret)
	if err != nil {
		utils.WriteError(w, http.StatusUnauthorized, err, "HandleRefreshToken", "User sent an invalid or expired refresh token", "Refresh token is invalid or has been expired")
		return
	}

	storedToken, err := h.authStore.GetRefreshTokenByUserID(r.Context(), claims.UserID)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleRefreshToken", "Failed get refresh token by user ID from database", fmt.Sprintf("No refresh token found with user ID %d", claims.UserID))
			return
		}
		utils.WriteError(w, http.StatusUnauthorized, err, "HandleRefreshToken", "Failed get refresh token by user ID from database", "Unauthorized")
		return
	}

	if storedToken.Jti != claims.RegisteredClaims.ID {
		utils.WriteError(w, http.StatusUnauthorized, fmt.Errorf("stored JTI does not match the claims ID"), "HandleRefreshToken", "Stored JTI does not match the claims ID", "Unauthorized")
		return
	}

	newAccessToken, err := utils.CreateJWT(claims.UserID, claims.Username, claims.Email, config.Envs.JWTSecret, 3600, h.UUIDGen)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "An error occured during the create JWT process", "An unexpected error occurred")
	}

	newRefreshToken, err := utils.CreateJWT(claims.UserID, claims.Username, claims.Email, config.Envs.JWTSecret, config.Envs.JWTExpirationInSeconds, h.UUIDGen)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "An error occured during the create JWT process", "An unexpected error occurred")
	}

	newRefreshTokenClaims, err := utils.VerifyJWT(newRefreshToken, config.Envs.JWTSecret)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUserLogin", "Failed to parse the new refresh token", "An unexpected error occurred")
		return
	}

	err = h.authStore.UpsertRefreshToken(
		r.Context(),
		types.UpdateRefreshTokenPayload{
			UserID:    newRefreshTokenClaims.UserID,
			Jti:       newRefreshTokenClaims.RegisteredClaims.ID,
			ExpiresAt: newRefreshTokenClaims.RegisteredClaims.ExpiresAt.Time,
		})
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleRefreshToken", "Failed to update refresh token", "Internal Server Error")
		return
	}

	utils.WriteJSON(w, http.StatusOK, types.UpdateRefreshTokenResponse{AccessToken: newAccessToken, RefreshToken: newRefreshToken})
}

================
File: service/auth/store_test.go
================
package auth

import (
	"context"
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/hoyci/book-store-api/types"
	"github.com/stretchr/testify/assert"
)

func TestGetRefreshTokenByUserID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewAuthStore(db)

	t.Run("database did not find any row", func(t *testing.T) {
		mock.ExpectQuery(`SELECT \* FROM refresh_tokens WHERE user_id = \$1`).
			WithArgs(1).
			WillReturnError(sql.ErrNoRows)

		refreshToken, err := store.GetRefreshTokenByUserID(context.Background(), 1)

		assert.Nil(t, refreshToken)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery(`SELECT \* FROM refresh_tokens WHERE user_id = \$1`).
			WithArgs(1).
			WillReturnError(fmt.Errorf("database connection error"))

		refreshToken, err := store.GetRefreshTokenByUserID(context.Background(), 1)

		assert.Error(t, err)
		assert.Zero(t, refreshToken)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully get user by ID", func(t *testing.T) {
		mock.ExpectQuery(`SELECT \* FROM refresh_tokens WHERE user_id = \$1`).
			WithArgs(1).
			WillReturnRows(sqlmock.NewRows([]string{"id", "user_id", "jti", "expires_at", "created_at"}).
				AddRow(1, 1, "31a0641b-e109-4467-b78c-13b72d0242a5", time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC), time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC)))

		refreshToken, err := store.GetRefreshTokenByUserID(context.Background(), 1)

		assert.NoError(t, err)
		assert.NotNil(t, refreshToken)
		assert.Equal(t, 1, refreshToken.UserID)
		assert.Equal(t, "31a0641b-e109-4467-b78c-13b72d0242a5", refreshToken.Jti)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestUpdateRefreshTokenByUserID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewAuthStore(db)
	payload := types.UpdateRefreshTokenPayload{
		UserID:    1,
		Jti:       "31a0641b-e109-4467-b78c-13b72d0242a5",
		ExpiresAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
	}

	t.Run("database did not find any row to update", func(t *testing.T) {
		mock.ExpectQuery(`
				INSERT INTO refresh_tokens \(user_id, jti, expires_at\) 
				VALUES \(\$1, \$2, \$3\) 
				ON CONFLICT \(user_id\) 
				DO UPDATE 
				SET jti = EXCLUDED\.jti, expires_at = EXCLUDED\.expires_at 
				RETURNING id, user_id, jti, created_at, expires_at
			`).
			WithArgs(payload.UserID, payload.Jti, payload.ExpiresAt).
			WillReturnError(sql.ErrNoRows)

		err := store.UpsertRefreshToken(context.Background(), payload)

		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery(`
				INSERT INTO refresh_tokens \(user_id, jti, expires_at\) 
				VALUES \(\$1, \$2, \$3\) 
				ON CONFLICT \(user_id\) 
				DO UPDATE 
				SET jti = EXCLUDED\.jti, expires_at = EXCLUDED\.expires_at 
				RETURNING id, user_id, jti, created_at, expires_at
			`).
			WithArgs(payload.UserID, payload.Jti, payload.ExpiresAt).
			WillReturnError(fmt.Errorf("database connection error"))

		err := store.UpsertRefreshToken(context.Background(), payload)

		assert.Error(t, err)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("conflict error on upsert", func(t *testing.T) {
		mock.ExpectQuery(`
				INSERT INTO refresh_tokens \(user_id, jti, expires_at\) 
				VALUES \(\$1, \$2, \$3\) 
				ON CONFLICT \(user_id\) 
				DO UPDATE 
				SET jti = EXCLUDED\.jti, expires_at = EXCLUDED\.expires_at 
				RETURNING id, user_id, jti, created_at, expires_at
			`).
			WithArgs(payload.UserID, payload.Jti, payload.ExpiresAt).
			WillReturnError(fmt.Errorf("unique constraint violation"))

		err := store.UpsertRefreshToken(context.Background(), payload)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "unique constraint violation")

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully update refresh token", func(t *testing.T) {
		mock.ExpectQuery(`
				INSERT INTO refresh_tokens \(user_id, jti, expires_at\) 
				VALUES \(\$1, \$2, \$3\) 
				ON CONFLICT \(user_id\) 
				DO UPDATE 
				SET jti = EXCLUDED\.jti, expires_at = EXCLUDED\.expires_at 
				RETURNING id, user_id, jti, created_at, expires_at
			`).
			WithArgs(payload.UserID, payload.Jti, payload.ExpiresAt).
			WillReturnRows(sqlmock.NewRows([]string{"id", "user_id", "jti", "created_at", "expires_at"}).
				AddRow(1, payload.UserID, payload.Jti, time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC), payload.ExpiresAt))

		err := store.UpsertRefreshToken(context.Background(), payload)

		assert.NoError(t, err)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

================
File: service/auth/store.go
================
package auth

import (
	"context"
	"database/sql"

	"github.com/hoyci/book-store-api/types"
)

type AuthStore struct {
	db *sql.DB
}

func NewAuthStore(db *sql.DB) *AuthStore {
	return &AuthStore{db: db}
}

func (s *AuthStore) GetRefreshTokenByUserID(ctx context.Context, userID int) (*types.RefreshToken, error) {
	token := &types.RefreshToken{}

	err := s.db.QueryRowContext(ctx, "SELECT * FROM refresh_tokens WHERE user_id = $1", userID).
		Scan(
			&token.ID,
			&token.UserID,
			&token.Jti,
			&token.CreatedAt,
			&token.ExpiresAt,
		)
	if err != nil {
		return nil, err
	}

	return token, nil
}

func (s *AuthStore) UpsertRefreshToken(ctx context.Context, payload types.UpdateRefreshTokenPayload) error {
	token := &types.RefreshToken{}

	err := s.db.QueryRowContext(
		ctx,
		`INSERT INTO refresh_tokens (user_id, jti, expires_at) 
         VALUES ($1, $2, $3) 
         ON CONFLICT (user_id) 
         DO UPDATE SET 
             jti = EXCLUDED.jti, 
             expires_at = EXCLUDED.expires_at 
         RETURNING id, user_id, jti, created_at, expires_at`,
		payload.UserID,
		payload.Jti,
		payload.ExpiresAt,
	).Scan(
		&token.ID,
		&token.UserID,
		&token.Jti,
		&token.CreatedAt,
		&token.ExpiresAt,
	)
	if err != nil {
		return err
	}

	return nil
}

================
File: service/book/routes_test.go
================
package book_test

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/service/book"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockBookStore struct {
	mock.Mock
}

func (m *MockBookStore) Create(ctx context.Context, book types.CreateBookPayload) (int, error) {
	args := m.Called(ctx, book)
	return args.Get(0).(int), args.Error(1)
}

func (m *MockBookStore) GetByID(ctx context.Context, id int) (*types.Book, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.Book), args.Error(1)
}

func (m *MockBookStore) UpdateByID(ctx context.Context, id int, newBook types.UpdateBookPayload) (*types.Book, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.Book), args.Error(1)
}

func (m *MockBookStore) DeleteByID(ctx context.Context, id int) (int, error) {
	args := m.Called(ctx, id)
	if val, ok := args.Get(0).(int); ok {
		return val, args.Error(1)
	}
	return 0, args.Error(1)
}

func TestHandleCreateBook(t *testing.T) {
	setupTestServer := func() (*MockBookStore, *httptest.Server, *mux.Router) {
		mockBookStore := new(MockBookStore)
		mockBookHandler := book.NewBookHandler(mockBookStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, mockBookHandler, nil, nil)
		ts := httptest.NewServer(router)
		return mockBookStore, ts, router
	}

	t.Run("it should throw an error when body is not a valid JSON", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		invalidBody := bytes.NewReader([]byte("INVALID JSON"))
		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/books", invalidBody)
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Body is not a valid json"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is a valid JSON but missing key", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		payload := types.CreateBookPayload{
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/books", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Name' is invalid: required"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw a database insert error", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("Create", mock.Anything, mock.Anything).Return(0, fmt.Errorf("failed to insert entity 'book': database error"))

		payload := types.CreateBookPayload{
			Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/books", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusInternalServerError, res.StatusCode)

		responseBody, _ := io.ReadAll(res.Body)
		expected := `{"error":"An unexpected error occurred"}`
		assert.JSONEq(t, expected, string(responseBody))
	})

	t.Run("it should successfully create a book", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("Create", mock.Anything, mock.Anything).Return(int(1), nil)

		payload := types.CreateBookPayload{
			Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/books", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusCreated, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"id":1}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

func TestHandleGetBookByID(t *testing.T) {
	setupTestServer := func() (*MockBookStore, *httptest.Server, *mux.Router) {
		mockBookStore := new(MockBookStore)
		mockBookHandler := book.NewBookHandler(mockBookStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, mockBookHandler, nil, nil)
		ts := httptest.NewServer(router)
		return mockBookStore, ts, router
	}

	t.Run("it should throw an error when call endpoint without book ID", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/books", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong book ID", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/books/johndoe", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Book ID must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent book ID", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("GetByID", mock.Anything, 1).Return(&types.Book{}, sql.ErrNoRows)

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/books/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No book found with ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return succssefully status and body when call endpoint with valid body", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("GetByID", mock.Anything, 1).Return(&types.Book{
			ID:            1,
			Name:          "Go Programming",
			Description:   "A book about Go programming",
			Author:        "John Doe",
			Genres:        []string{"Programming"},
			ReleaseYear:   2024,
			NumberOfPages: 300,
			ImageUrl:      "http://example.com/go.jpg",
			CreatedAt:     time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
			DeletedAt:     nil,
			UpdatedAt:     nil,
		}, nil)

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/books/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{
			"id": 1,
			"name": "Go Programming",
			"description": "A book about Go programming",
			"author": "John Doe",
			"genres": ["Programming"],
			"release_year": 2024,
			"number_of_pages": 300,
			"image_url": "http://example.com/go.jpg",
			"created_at": "0001-01-01T00:00:00Z",
			"deleted_at": null,
			"updated_at": null
		}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

func TestHandleUpdateBookByID(t *testing.T) {
	setupTestServer := func() (*MockBookStore, *httptest.Server, *mux.Router) {
		mockBookStore := new(MockBookStore)
		mockBookHandler := book.NewBookHandler(mockBookStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, mockBookHandler, nil, nil)
		ts := httptest.NewServer(router)
		return mockBookStore, ts, router
	}

	t.Run("it should throw an error when call endpoint without book ID", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/books", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong book ID", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/books/johndoe", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Book ID must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when no fields are provided for update", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		emptyPayload := `{}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/books/1", bytes.NewBufferString(emptyPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field validation for 'UpdateBookPayload' failed on the 'atleastonefield' tag"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is invalid", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		invalidPayload := `{"name": ""}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/books/1", bytes.NewBufferString(invalidPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field validation for 'Name' failed on the 'min' tag"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent user ID", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("UpdateByID", mock.Anything, 1, mock.Anything).Return(&types.Book{}, sql.ErrNoRows)

		validPayload := `{
			"name": "Go Programming - Updated",
			"genres": ["Programming", "Go"],
			"image_url": "http://example.com/go_updated.jpg"
		}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/books/1", bytes.NewBufferString(validPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No book found with ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return successfully status and body when the book is updated", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("UpdateByID", mock.Anything, 1, mock.Anything).Return(&types.Book{
			ID:            1,
			Name:          "Go Programming - Updated",
			Description:   "Updated description",
			Author:        "John Doe",
			Genres:        []string{"Programming", "Go"},
			ReleaseYear:   2024,
			NumberOfPages: 350,
			ImageUrl:      "http://example.com/go_updated.jpg",
			CreatedAt:     time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
			DeletedAt:     nil,
			UpdatedAt:     utils.TimePtr(time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC)),
		}, nil)

		validPayload := `{
			"name": "Go Programming - Updated",
			"genres": ["Programming", "Go"],
			"image_url": "http://example.com/go_updated.jpg"
		}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/books/1", bytes.NewBufferString(validPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{
			"id": 1,
			"name": "Go Programming - Updated",
			"description": "Updated description",
			"author": "John Doe",
			"genres": ["Programming", "Go"],
			"release_year": 2024,
			"number_of_pages": 350,
			"image_url": "http://example.com/go_updated.jpg",
			"created_at": "0001-01-01T00:00:00Z",
			"updated_at": "0001-01-01T00:00:00Z",
			"deleted_at": null 
		}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

func TestHandleDeleteBookByID(t *testing.T) {
	setupTestServer := func() (*MockBookStore, *httptest.Server, *mux.Router) {
		mockBookStore := new(MockBookStore)
		mockBookHandler := book.NewBookHandler(mockBookStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, mockBookHandler, nil, nil)
		ts := httptest.NewServer(router)
		return mockBookStore, ts, router
	}

	t.Run("it should throw an error when call endpoint without book ID", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/books", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong ID", func(t *testing.T) {
		_, ts, router := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/books/johndoe", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Book ID must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent user ID", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("DeleteByID", mock.Anything, mock.Anything).Return(int(0), sql.ErrNoRows)

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/books/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No book found with ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return succssefully status and body when call endpoint with valid body", func(t *testing.T) {
		mockBookStore, ts, router := setupTestServer()
		defer ts.Close()

		mockBookStore.On("DeleteByID", mock.Anything, mock.Anything).Return(int(1), nil)

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/books/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"id":1}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

================
File: service/book/routes.go
================
package book

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-playground/validator/v10"
	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
)

var validate = validator.New()

func updateBookPayloadStructLevelValidation(sl validator.StructLevel) {
	payload := sl.Current().Interface().(types.UpdateBookPayload)

	if payload.Name == nil &&
		payload.Description == nil &&
		payload.Author == nil &&
		payload.Genres == nil &&
		payload.ReleaseYear == nil &&
		payload.NumberOfPages == nil &&
		payload.ImageUrl == nil {
		sl.ReportError(payload, "UpdateBookPayload", "", "atleastonefield", "")
	}
}

type BookHandler struct {
	bookStore types.BookStore
}

func NewBookHandler(bookStore types.BookStore) *BookHandler {
	validate.RegisterStructValidation(updateBookPayloadStructLevelValidation, types.UpdateBookPayload{})

	return &BookHandler{bookStore: bookStore}
}

func (h *BookHandler) HandleCreateBook(w http.ResponseWriter, r *http.Request) {
	var payload types.CreateBookPayload
	if err := utils.ParseJSON(r, &payload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleCreateBook", "User sent request with an invalid JSON", "Body is not a valid json")
		return
	}

	if err := validate.Struct(payload); err != nil {
		var errorMessages []string
		for _, e := range err.(validator.ValidationErrors) {
			errorMessages = append(errorMessages, fmt.Sprintf("Field '%s' is invalid: %s", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, err, "HandleCreateBook", "User sent a request containing JSON with information outside the permitted format", errorMessages)
		return
	}

	id, err := h.bookStore.Create(r.Context(), payload)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleCreateBook", "Failed to insert book into database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusCreated, types.CreateBookResponse{ID: id})
}

func (h *BookHandler) HandleGetBookByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleGetBookByID", "User sent request with an invalid ID", "Book ID must be a positive integer")
		return
	}

	book, err := h.bookStore.GetByID(r.Context(), id)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleGetBookByID", "Failed to get user by id from database", fmt.Sprintf("No book found with ID %d", id))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleGetBookByID", "Failed to get user by id from database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusOK, book)
}

func (h *BookHandler) HandleUpdateBookByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleUpdateBookByID", "User sent request with an invalid ID", "Book ID must be a positive integer")
		return
	}

	var payload types.UpdateBookPayload
	if err := utils.ParseJSON(r, &payload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleUpdateBookByID", "User sent request with an invalid JSON", "Body is not a valid json")
		return
	}

	if err := validate.Struct(payload); err != nil {
		var errorMessages []string
		for _, e := range err.(validator.ValidationErrors) {
			errorMessages = append(errorMessages, fmt.Sprintf("Field validation for '%s' failed on the '%s' tag", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, err, "HandleUpdateBookByID", "User sent a request with JSON outside the permitted format", errorMessages)
		return
	}

	book, err := h.bookStore.UpdateByID(r.Context(), id, payload)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleUpdateBookByID", "Failed to update book by id in database", fmt.Sprintf("No book found with ID %d", id))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUpdateBookByID", "Failed to update book by id in database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusOK, book)
}

func (h *BookHandler) HandleDeleteBookByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleDeleteBookByID", "User sent request with an invalid ID", "Book ID must be a positive integer")
		return
	}

	returnedID, err := h.bookStore.DeleteByID(r.Context(), id)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleDeleteBookByID", "Failed to delete user by id from database", fmt.Sprintf("No book found with ID %d", id))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleDeleteBookByID", "Failed to delete user by id from database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusOK, types.DeleteBookByIDResponse{ID: returnedID})
}

================
File: service/book/store_test.go
================
package book

import (
	"context"
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/lib/pq"
	"github.com/stretchr/testify/assert"
)

func TestCreateBook(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewBookStore(db)
	book := types.CreateBookPayload{
		Name:          "Go Programming",
		Description:   "A book about Go programming",
		Author:        "John Doe",
		Genres:        []string{"Programming"},
		ReleaseYear:   2024,
		NumberOfPages: 300,
		ImageUrl:      "http://example.com/go.jpg",
	}

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("INSERT INTO books").
			WithArgs(book.Name, book.Description, book.Author, pq.Array(book.Genres), book.ReleaseYear, book.NumberOfPages, book.ImageUrl).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.Create(context.Background(), book)

		assert.Error(t, err)
		assert.Zero(t, id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully create book", func(t *testing.T) {
		mock.ExpectQuery("INSERT INTO books").
			WithArgs(book.Name, book.Description, book.Author, pq.Array(book.Genres), book.ReleaseYear, book.NumberOfPages, book.ImageUrl).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

		id, err := store.Create(context.Background(), book)

		assert.NoError(t, err)
		assert.Equal(t, int(1), id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestGetBookByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewBookStore(db)
	expectedCreatedAt := time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC)

	t.Run("database did not find any row", func(t *testing.T) {
		mock.ExpectQuery("SELECT \\* FROM books WHERE id = \\$1 AND deleted_at IS null").
			WithArgs(1).
			WillReturnError(sql.ErrNoRows)

		book, err := store.GetByID(context.Background(), 1)

		assert.Nil(t, book)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("SELECT \\* FROM books WHERE id = \\$1 AND deleted_at IS null").
			WithArgs(1).
			WillReturnError(fmt.Errorf("database connection error"))

		book, err := store.GetByID(context.Background(), 1)

		assert.Error(t, err)
		assert.Zero(t, book)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully get book by ID", func(t *testing.T) {
		mock.ExpectQuery("SELECT \\* FROM books WHERE id = \\$1 AND deleted_at IS null").
			WithArgs(1).
			WillReturnRows(sqlmock.NewRows([]string{"id", "name", "description", "author", "genres", "release_year", "number_of_pages", "image_url", "created_at", "updated_at", "deleted_at"}).
				AddRow(1, "Go Programming", "A book about Go programming", "John Doe", pq.Array([]string{"Programming"}), 2024, 300, "http://example.com/go.jpg", expectedCreatedAt, nil, nil))

		expectedID := 1

		book, err := store.GetByID(context.Background(), expectedID)

		assert.NoError(t, err)
		assert.NotNil(t, book)
		assert.Equal(t, expectedID, book.ID)
		assert.Equal(t, "Go Programming", book.Name)
		assert.Equal(t, expectedCreatedAt, book.CreatedAt)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestUpdateBook(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewBookStore(db)

	t.Run("no fields to update", func(t *testing.T) {
		emptyUpdates := types.UpdateBookPayload{}
		result, err := store.UpdateByID(context.Background(), 1, emptyUpdates)

		assert.Error(t, err, "no fields to update for book with ID %d", 1)
		assert.Nil(t, result)
		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database did not find any row", func(t *testing.T) {
		updates := types.UpdateBookPayload{
			Name:        utils.StringPtr("Updated Book Name"),
			Description: utils.StringPtr("Updated Description"),
			Genres:      &[]string{"Genre1", "Genre2"},
			ReleaseYear: utils.IntPtr(2025),
		}

		mock.ExpectQuery("UPDATE books SET").
			WithArgs(
				"Updated Book Name",
				"Updated Description",
				pq.Array([]string{"Genre1", "Genre2"}),
				2025,
				1,
			).
			WillReturnError(sql.ErrNoRows)

		id, err := store.UpdateByID(context.Background(), 1, updates)

		assert.Nil(t, id)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		updates := types.UpdateBookPayload{
			Name:        utils.StringPtr("Updated Book Name"),
			Description: utils.StringPtr("Updated Description"),
			Genres:      &[]string{"Genre1", "Genre2"},
			ReleaseYear: utils.IntPtr(2025),
		}

		mock.ExpectQuery("UPDATE books SET").
			WithArgs(
				"Updated Book Name",
				"Updated Description",
				pq.Array([]string{"Genre1", "Genre2"}),
				2025,
				1,
			).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.UpdateByID(context.Background(), 1, updates)

		assert.Error(t, err)
		assert.Zero(t, id)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully update book", func(t *testing.T) {
		updates := types.UpdateBookPayload{
			Name:        utils.StringPtr("Updated Book Name"),
			Description: utils.StringPtr("Updated Description"),
			Genres:      &[]string{"Genre1", "Genre2"},
			ReleaseYear: utils.IntPtr(2025),
		}

		mock.ExpectQuery("UPDATE books SET").
			WithArgs(
				"Updated Book Name",
				"Updated Description",
				pq.Array([]string{"Genre1", "Genre2"}),
				2025,
				1,
			).
			WillReturnRows(sqlmock.NewRows([]string{
				"id", "name", "description", "author", "genres", "release_year", "number_of_pages", "image_url", "created_at", "updated_at",
			}).AddRow(
				1,
				"Updated Book Name",
				"Updated Description",
				"Author Name",
				pq.Array([]string{"Genre1", "Genre2"}),
				2025,
				300,
				"http://example.com/image.jpg",
				time.Now(),
				time.Now(),
			))

		result, err := store.UpdateByID(context.Background(), 1, updates)

		assert.NoError(t, err)
		assert.NotNil(t, result)
		assert.Equal(t, 1, result.ID)
		assert.Equal(t, "Updated Book Name", result.Name)
		assert.Equal(t, "Updated Description", result.Description)
		assert.Equal(t, []string{"Genre1", "Genre2"}, result.Genres)

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err)
	})
}

func TestDeleteByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewBookStore(db)

	t.Run("database did not find any row", func(t *testing.T) {
		mock.ExpectQuery("UPDATE books SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnError(sql.ErrNoRows)

		id, err := store.DeleteByID(context.Background(), 1)

		assert.Equal(t, id, 0)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("UPDATE books SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.DeleteByID(context.Background(), 1)

		assert.Error(t, err)
		assert.Zero(t, id)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully delete book by ID", func(t *testing.T) {
		mock.ExpectQuery("UPDATE books SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

		id, err := store.DeleteByID(context.Background(), 1)
		expectedID := 1

		assert.NoError(t, err)
		assert.Equal(t, expectedID, id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

================
File: service/book/store.go
================
package book

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/lib/pq"
)

type BookStore struct {
	db *sql.DB
}

func NewBookStore(db *sql.DB) *BookStore {
	return &BookStore{db: db}
}

func (s *BookStore) Create(ctx context.Context, book types.CreateBookPayload) (int, error) {
	var id int
	err := s.db.QueryRowContext(
		ctx,
		"INSERT INTO books (name, description, author, genres, release_year, number_of_pages, image_url) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id",
		book.Name,
		book.Description,
		book.Author,
		pq.Array(book.Genres),
		book.ReleaseYear,
		book.NumberOfPages,
		book.ImageUrl,
	).Scan(&id)

	if err != nil {
		return 0, err
	}

	return id, nil
}

func (s *BookStore) GetByID(ctx context.Context, id int) (*types.Book, error) {
	book := &types.Book{}

	err := s.db.QueryRowContext(ctx, "SELECT * FROM books WHERE id = $1 AND deleted_at IS null", id).
		Scan(
			&book.ID,
			&book.Name,
			&book.Description,
			&book.Author,
			pq.Array(&book.Genres),
			&book.ReleaseYear,
			&book.NumberOfPages,
			&book.ImageUrl,
			&book.CreatedAt,
			&book.UpdatedAt,
			&book.DeletedAt,
		)
	if err != nil {
		return nil, err
	}

	return book, nil
}

func (s *BookStore) UpdateByID(ctx context.Context, id int, newBook types.UpdateBookPayload) (*types.Book, error) {
	query := fmt.Sprintf("UPDATE books SET updated_at = '%s', ", time.Now().Format("2006-01-02 15:04:05"))
	args := []any{}
	counter := 1

	fields := []struct {
		name  string
		value any
	}{
		{"name", newBook.Name},
		{"description", newBook.Description},
		{"author", newBook.Author},
		{"genres", newBook.Genres},
		{"release_year", newBook.ReleaseYear},
		{"number_of_pages", newBook.NumberOfPages},
		{"image_url", newBook.ImageUrl},
	}

	for _, field := range fields {
		if !utils.IsNil(field.value) {
			query += fmt.Sprintf("%s = $%d, ", field.name, counter)
			if ptr, ok := field.value.(*[]string); ok {
				args = append(args, pq.Array(*ptr))
			} else {
				args = append(args, field.value)
			}
			counter++
		}
	}

	if len(args) == 0 {
		return nil, fmt.Errorf("no fields to update for book with ID %d", id)
	}

	query = query[:len(query)-2] + fmt.Sprintf(" WHERE id = $%d RETURNING id, name, description, author, genres, release_year, number_of_pages, image_url, created_at, updated_at", counter)
	args = append(args, id)

	updatedBook := &types.Book{}
	err := s.db.QueryRowContext(ctx, query, args...).Scan(
		&updatedBook.ID,
		&updatedBook.Name,
		&updatedBook.Description,
		&updatedBook.Author,
		pq.Array(&updatedBook.Genres),
		&updatedBook.ReleaseYear,
		&updatedBook.NumberOfPages,
		&updatedBook.ImageUrl,
		&updatedBook.CreatedAt,
		&updatedBook.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return updatedBook, nil
}

func (s *BookStore) DeleteByID(ctx context.Context, id int) (int, error) {
	var returnedID int
	err := s.db.QueryRowContext(
		ctx,
		"UPDATE books SET deleted_at = $2 WHERE id = $1 RETURNING id",
		id,
		time.Now(),
	).Scan(&returnedID)
	if err != nil {
		return 0, err
	}

	return returnedID, nil
}

================
File: service/healthcheck/routes_test.go
================
package healthcheck_test

import (
	"io"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/service/healthcheck"
	"github.com/stretchr/testify/assert"
)

func TestHealthCheck(t *testing.T) {
	t.Run("should return environment as production", func(t *testing.T) {
		mockConfig := config.Config{
			Environment: "production",
		}
		healthCheckHandler := healthcheck.NewHealthCheckHandler(mockConfig)

		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(healthCheckHandler, nil, nil, nil)

		ts := httptest.NewServer(router)
		defer ts.Close()

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/healthcheck", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"status":"available","system_info":{"environment":"production"}}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("should return environment as production", func(t *testing.T) {
		mockConfig := config.Config{
			Environment: "production",
		}
		healthCheckHandler := healthcheck.NewHealthCheckHandler(mockConfig)

		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(healthCheckHandler, nil, nil, nil)

		ts := httptest.NewServer(router)
		defer ts.Close()

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/healthcheck", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"status":"available","system_info":{"environment":"production"}}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

================
File: service/healthcheck/routes.go
================
package healthcheck

import (
	"net/http"

	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
)

type HealthCheckHandler struct {
	cfg config.Config
}

func NewHealthCheckHandler(cfg config.Config) *HealthCheckHandler {
	return &HealthCheckHandler{
		cfg: cfg,
	}
}

func (h *HealthCheckHandler) HandleHealthCheck(w http.ResponseWriter, r *http.Request) {
	utils.WriteJSON(w, http.StatusOK, &types.HealthcheckResponse{
		Status: "available",
		SystemInfo: map[string]string{
			"environment": h.cfg.Environment,
		},
	})
}

================
File: service/user/routes_test.go
================
package user_test

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/cmd/api"
	"github.com/hoyci/book-store-api/config"
	"github.com/hoyci/book-store-api/service/user"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockUserStore struct {
	mock.Mock
}

func (m *MockUserStore) Create(ctx context.Context, user types.CreateUserDatabasePayload) (*types.UserResponse, error) {
	args := m.Called(ctx, user)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) GetByID(ctx context.Context, id int) (*types.UserResponse, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) GetByEmail(ctx context.Context, email string) (*types.UserResponse, error) {
	args := m.Called(ctx, email)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) UpdateByID(ctx context.Context, id int, newUser types.UpdateUserPayload) (*types.UserResponse, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*types.UserResponse), args.Error(1)
}

func (m *MockUserStore) DeleteByID(ctx context.Context, id int) (int, error) {
	args := m.Called(ctx, id)
	if val, ok := args.Get(0).(int); ok {
		return val, args.Error(1)
	}
	return 0, args.Error(1)
}

func TestHandleCreateUser(t *testing.T) {
	setupTestServer := func() (*MockUserStore, *httptest.Server, *mux.Router, config.Config) {
		mockUserStore := new(MockUserStore)
		mockUserHandler := user.NewUserHandler(mockUserStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, nil, mockUserHandler, nil)
		ts := httptest.NewServer(router)
		return mockUserStore, ts, router, apiServer.Config
	}

	t.Run("it should throw an error when body is not a valid JSON", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		invalidBody := bytes.NewReader([]byte("INVALID JSON"))
		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users", invalidBody)
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Body is not a valid json"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is a valid JSON but missing key", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.CreateUserRequestPayload{}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Username' is invalid: required", "Field 'Email' is invalid: required", "Field 'Password' is invalid: required", "Field 'ConfirmPassword' is invalid: required"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body does not contain a valid email", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.CreateUserRequestPayload{
			Username:        "JohnDoe",
			Email:           "johndoe",
			Password:        "123mudar",
			ConfirmPassword: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Email' is invalid: email"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when password or confirmPassword is smaller than 8 chars", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		payload := types.CreateUserRequestPayload{
			Username:        "JohnDoe",
			Email:           "johndoe@email.com",
			Password:        "12345",
			ConfirmPassword: "12345",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field 'Password' is invalid: min", "Field 'ConfirmPassword' is invalid: min"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw a database insert error", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("Create", mock.Anything, mock.Anything).Return((*types.UserResponse)(nil), fmt.Errorf("failed to insert entity 'user': database error"))

		payload := types.CreateUserRequestPayload{
			Username:        "JohnDoe",
			Email:           "johndoe@email.com",
			Password:        "123mudar",
			ConfirmPassword: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusInternalServerError, res.StatusCode)

		responseBody, _ := io.ReadAll(res.Body)
		expected := `{"error":"An unexpected error occurred"}`
		assert.JSONEq(t, expected, string(responseBody))
	})

	t.Run("it should successfully create a user", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("Create", mock.Anything, mock.Anything).Return(
			&types.UserResponse{
				ID:        1,
				Username:  "JohnDoe",
				Email:     "johndoe@email.com",
				CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
				UpdatedAt: nil,
				DeletedAt: nil,
			},
			nil,
		)

		payload := types.CreateUserRequestPayload{
			Username:        "JohnDoe",
			Email:           "johndoe@email.com",
			Password:        "123mudar",
			ConfirmPassword: "123mudar",
		}
		marshalled, _ := json.Marshal(payload)

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users", bytes.NewBuffer(marshalled))
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusCreated, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		var responseMap map[string]interface{}
		err = json.Unmarshal(responseBody, &responseMap)
		if err != nil {
			t.Fatalf("Failed to unmarshal response body: %v", err)
		}

		responseMessage, ok := responseMap["message"].(string)
		if !ok {
			t.Fatalf("Token not found or not a string")
		}
		assert.Equal(t, "User successfully created", responseMessage)
	})
}

func TestHandleGetUserById(t *testing.T) {
	setupTestServer := func() (*MockUserStore, *httptest.Server, *mux.Router, config.Config) {
		mockUserStore := new(MockUserStore)
		mockUserHandler := user.NewUserHandler(mockUserStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, nil, mockUserHandler, nil)
		ts := httptest.NewServer(router)
		return mockUserStore, ts, router, apiServer.Config
	}

	t.Run("it should throw an error when call endpoint without user ID", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users/", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong user ID", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/users/johndoe", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"User ID must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent user ID", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("GetByID", mock.Anything, mock.Anything).Return(&types.UserResponse{}, sql.ErrNoRows)

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/users/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No user found with ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return succssefully status and body when call endpoint with valid body", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("GetByID", mock.Anything, 1).Return(&types.UserResponse{
			ID:        1,
			Username:  "johndoe",
			Email:     "johndoe@email.com",
			CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
			DeletedAt: nil,
			UpdatedAt: nil,
		}, nil)

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/users/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{
			"id": 1,
			"username": "johndoe",
			"email": "johndoe@email.com",
			"createdAt": "0001-01-01T00:00:00Z",
			"deletedAt": null,
			"updatedAt": null
		}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

func TestHandleUpdateUserById(t *testing.T) {
	setupTestServer := func() (*MockUserStore, *httptest.Server, *mux.Router, config.Config) {
		mockUserStore := new(MockUserStore)
		mockUserHandler := user.NewUserHandler(mockUserStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, nil, mockUserHandler, nil)
		ts := httptest.NewServer(router)
		return mockUserStore, ts, router, apiServer.Config
	}

	t.Run("it should throw an error when call endpoint without user ID", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodPost, ts.URL+"/api/v1/users/", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong user ID", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodGet, ts.URL+"/api/v1/users/johndoe", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"User ID must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when no fields are provided for update", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		emptyPayload := `{}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/users/1", bytes.NewBufferString(emptyPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": ["Field validation for 'UpdateUserPayload' failed on the 'atleastonefield' tag"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when body is invalid", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		invalidPayload := `{"username": "", "email": ""}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/users/1", bytes.NewBufferString(invalidPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":["Field validation for 'Username' failed on the 'min' tag", "Field validation for 'Email' failed on the 'email' tag"]}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent user ID", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("UpdateByID", mock.Anything, mock.Anything, mock.Anything).Return(&types.UserResponse{}, sql.ErrNoRows)

		validPayload := `{
			"username": "johndoe - updated",
			"email": "johndoeupdated@email.com"
		}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/users/1", bytes.NewBufferString(validPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No user found with ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return successfully status and body when the user is updated", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("UpdateByID", mock.Anything, 1, mock.Anything).Return(&types.UserResponse{
			ID:        1,
			Username:  "johndoe - updated",
			Email:     "johndoeupdated@email.com",
			CreatedAt: time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC),
			DeletedAt: nil,
			UpdatedAt: utils.TimePtr(time.Date(0001, 01, 01, 0, 0, 0, 0, time.UTC)),
		}, nil)

		validPayload := `{
			"username": "johndoe - updated",
			"email": "johndoeupdated@email.com"
		}`
		req := httptest.NewRequest(http.MethodPut, ts.URL+"/api/v1/users/1", bytes.NewBufferString(validPayload))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{
			"id": 1,
			"username":  "johndoe - updated",
			"email": "johndoeupdated@email.com",
			"createdAt": "0001-01-01T00:00:00Z",
			"updatedAt": "0001-01-01T00:00:00Z",
			"deletedAt": null 
		}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

func TestHandleDeleteBookByID(t *testing.T) {
	setupTestServer := func() (*MockUserStore, *httptest.Server, *mux.Router, config.Config) {
		mockUserStore := new(MockUserStore)
		mockUserHandler := user.NewUserHandler(mockUserStore)
		apiServer := api.NewApiServer(":8080", nil)
		router := apiServer.SetupRouter(nil, nil, mockUserHandler, nil)
		ts := httptest.NewServer(router)
		return mockUserStore, ts, router, apiServer.Config
	}

	t.Run("it should throw an error when call endpoint without book ID", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/users", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)
	})

	t.Run("it should throw an error when call endpoint with wrong ID", func(t *testing.T) {
		_, ts, router, _ := setupTestServer()
		defer ts.Close()

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/users/anything", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error":"Book ID must be a positive integer"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should throw an error when call endpoint with a non-existent user ID", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("DeleteByID", mock.Anything, mock.Anything).Return(0, sql.ErrNoRows)

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/users/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusNotFound, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"error": "No user found with ID 1"}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})

	t.Run("it should return succssefully status and body when call endpoint with valid body", func(t *testing.T) {
		mockUserStore, ts, router, _ := setupTestServer()
		defer ts.Close()

		mockUserStore.On("DeleteByID", mock.Anything, mock.Anything).Return(int(1), nil)

		req := httptest.NewRequest(http.MethodDelete, ts.URL+"/api/v1/users/1", nil)
		w := httptest.NewRecorder()

		router.ServeHTTP(w, req)

		res := w.Result()
		defer res.Body.Close()

		assert.Equal(t, http.StatusOK, res.StatusCode)

		responseBody, err := io.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Failed to read response body: %v", err)
		}

		expectedResponse := `{"id":1}`
		assert.JSONEq(t, expectedResponse, string(responseBody))
	})
}

================
File: service/user/routes.go
================
package user

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-playground/validator/v10"
	"github.com/gorilla/mux"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
)

var validate = validator.New()

func passwordValidator(sl validator.StructLevel) {
	data := sl.Current().Interface().(types.CreateUserRequestPayload)
	if data.Password != data.ConfirmPassword {
		sl.ReportError(data.ConfirmPassword, "ConfirmPassword", "ConfirmPassword", "password_mismatch", "")
	}
}

func updateUserPayloadStructLevelValidation(sl validator.StructLevel) {
	payload := sl.Current().Interface().(types.UpdateUserPayload)

	if payload.Username == nil &&
		payload.Email == nil {
		sl.ReportError(payload, "UpdateUserPayload", "", "atleastonefield", "")
	}
}

type UserHandler struct {
	userStore types.UserStore
}

func NewUserHandler(userStore types.UserStore) *UserHandler {
	validate.RegisterStructValidation(passwordValidator, types.CreateUserRequestPayload{})
	validate.RegisterStructValidation(updateUserPayloadStructLevelValidation, types.UpdateUserPayload{})

	return &UserHandler{userStore: userStore}
}

func (h *UserHandler) HandleCreateUser(w http.ResponseWriter, r *http.Request) {
	var requestPayload types.CreateUserRequestPayload
	if err := utils.ParseJSON(r, &requestPayload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleCreateUser", "User sent request with an invalid JSON", "Body is not a valid json")
		return
	}

	if err := validate.Struct(requestPayload); err != nil {
		var errorMessages []string
		for _, e := range err.(validator.ValidationErrors) {
			errorMessages = append(errorMessages, fmt.Sprintf("Field '%s' is invalid: %s", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, err, "HandleCreateUser", "User sent a request containing JSON with information outside the permitted format", errorMessages)
		return
	}

	hashedPassword, err := utils.HashPassword(requestPayload.Password)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleCreateUser", "An error occured during the hash password process", "An unexpected error occurred")
	}

	var databasePayload = types.CreateUserDatabasePayload{
		Username:     requestPayload.Username,
		Email:        requestPayload.Email,
		PasswordHash: hashedPassword,
	}

	_, err = h.userStore.Create(r.Context(), databasePayload)
	if err != nil {
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleCreateUser", "Failed to insert user into database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusCreated, map[string]string{"message": "User successfully created"})
}

func (h *UserHandler) HandleGetUserByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleGetUserByID", "User sent request with an invalid ID", "User ID must be a positive integer")
		return
	}

	user, err := h.userStore.GetByID(r.Context(), id)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleDeleteUserByID", "Failed to get user by id from database", fmt.Sprintf("No user found with ID %d", id))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleGetUserByID", "Failed to get user by id from database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusOK, user)
}

func (h *UserHandler) HandleUpdateUserByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleUpdateUserByID", "User sent request with an invalid ID", "User ID must be a positive integer")
		return
	}

	var payload types.UpdateUserPayload
	if err := utils.ParseJSON(r, &payload); err != nil {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleUpdateUserByID", "User sent request with an invalid JSON", "Body is not a valid json")
		return
	}

	if err := validate.Struct(payload); err != nil {
		var errorMessages []string
		for _, e := range err.(validator.ValidationErrors) {
			errorMessages = append(errorMessages, fmt.Sprintf("Field validation for '%s' failed on the '%s' tag", e.Field(), e.Tag()))
		}

		utils.WriteError(w, http.StatusBadRequest, err, "HandleUpdateUserByID", "User sent a request with JSON outside the permitted format", errorMessages)
		return
	}

	user, err := h.userStore.UpdateByID(r.Context(), id, payload)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleDeleteUserByID", "Failed to update user by id in database", fmt.Sprintf("No user found with ID %d", id))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleUpdateUserByID", "Failed to update user by id in database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusOK, user)
}

func (h *UserHandler) HandleDeleteUserByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		utils.WriteError(w, http.StatusBadRequest, err, "HandleDeleteUserByID", "User sent request with an invalid ID", "Book ID must be a positive integer")
		return
	}

	returnedID, err := h.userStore.DeleteByID(r.Context(), id)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.WriteError(w, http.StatusNotFound, err, "HandleDeleteUserByID", "Failed to delete user by id from database", fmt.Sprintf("No user found with ID %d", id))
			return
		}
		utils.WriteError(w, http.StatusInternalServerError, err, "HandleDeleteUserByID", "Failed to delete user by id from database", "An unexpected error occurred")
		return
	}

	utils.WriteJSON(w, http.StatusOK, types.DeleteUserByIDResponse{ID: returnedID})
}

================
File: service/user/store_test.go
================
package user

import (
	"context"
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/stretchr/testify/assert"
)

func TestCreateUser(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewUserStore(db)
	user := types.CreateUserDatabasePayload{
		Username:     "JohnDoe",
		Email:        "johndoe@email.com",
		PasswordHash: "2345678",
	}

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("INSERT INTO users").
			WithArgs(user.Username, user.Email, user.PasswordHash).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.Create(context.Background(), user)

		assert.Error(t, err)
		assert.Zero(t, id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully create user", func(t *testing.T) {
		mock.ExpectQuery("INSERT INTO users").
			WithArgs(user.Username, user.Email, user.PasswordHash).
			WillReturnRows(
				sqlmock.NewRows([]string{
					"id", "username", "email", "created_at", "updated_at", "deleted_at",
				}).AddRow(
					1,
					"JohnDoe",
					"johndoe@email.com",
					time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC),
					time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC),
					time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC),
				))

		newUser, err := store.Create(context.Background(), user)

		assert.NoError(t, err)
		assert.Equal(t, 1, newUser.ID)
		assert.Equal(t, user.Username, newUser.Username)
		assert.Equal(t, user.Email, newUser.Email)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestGetUserByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewUserStore(db)
	expectedCreatedAt := time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC)

	t.Run("database did not find any row", func(t *testing.T) {
		mock.ExpectQuery("SELECT *").
			WithArgs(1).
			WillReturnError(sql.ErrNoRows)

		user, err := store.GetByID(context.Background(), 1)

		assert.Nil(t, user)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("SELECT *").
			WithArgs(1).
			WillReturnError(fmt.Errorf("database connection error"))

		user, err := store.GetByID(context.Background(), 1)

		assert.Error(t, err)
		assert.Zero(t, user)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully get user by ID", func(t *testing.T) {
		mock.ExpectQuery("SELECT id, username, email, created_at, updated_at, deleted_at FROM users WHERE id = \\$1 AND deleted_at IS null").
			WithArgs(1).
			WillReturnRows(sqlmock.NewRows([]string{"id", "username", "email", "created_at", "updated_at", "deleted_at"}).
				AddRow(1, "johndoe", "johndoe@email.com", expectedCreatedAt, nil, nil))

		expectedID := 1

		user, err := store.GetByID(context.Background(), expectedID)

		assert.NoError(t, err)
		assert.NotNil(t, user)
		assert.Equal(t, expectedID, user.ID)
		assert.Equal(t, "johndoe", user.Username)
		assert.Equal(t, "johndoe@email.com", user.Email)
		assert.Equal(t, expectedCreatedAt, user.CreatedAt)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestGetUserByEmail(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewUserStore(db)
	expectedCreatedAt := time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC)

	t.Run("database did not find any row", func(t *testing.T) {
		mock.ExpectQuery("SELECT *").
			WithArgs("johndoe@email.com").
			WillReturnError(sql.ErrNoRows)

		user, err := store.GetByEmail(context.Background(), "johndoe@email.com")

		assert.Nil(t, user)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("SELECT *").
			WithArgs("johndoe@email.com").
			WillReturnError(fmt.Errorf("database connection error"))

		user, err := store.GetByEmail(context.Background(), "johndoe@email.com")

		assert.Error(t, err)
		assert.Zero(t, user)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully get user by ID", func(t *testing.T) {
		mock.ExpectQuery("SELECT id, username, email, created_at, updated_at, deleted_at FROM users WHERE email = \\$1 AND deleted_at IS null").
			WithArgs("johndoe@email.com").
			WillReturnRows(sqlmock.NewRows([]string{"id", "username", "email", "created_at", "updated_at", "deleted_at"}).
				AddRow(1, "johndoe", "johndoe@email.com", expectedCreatedAt, nil, nil))

		expectedID := 1

		user, err := store.GetByEmail(context.Background(), "johndoe@email.com")

		assert.NoError(t, err)
		assert.NotNil(t, user)
		assert.Equal(t, expectedID, user.ID)
		assert.Equal(t, "johndoe", user.Username)
		assert.Equal(t, "johndoe@email.com", user.Email)
		assert.Equal(t, expectedCreatedAt, user.CreatedAt)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

func TestUpdateBook(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewUserStore(db)

	t.Run("no fields to update", func(t *testing.T) {
		emptyUpdates := types.UpdateUserPayload{}
		result, err := store.UpdateByID(context.Background(), 1, emptyUpdates)

		assert.Error(t, err, "no fields to update for user with ID %d", 1)
		assert.Nil(t, result)
		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database did not find any row", func(t *testing.T) {
		updates := types.UpdateUserPayload{
			Username: utils.StringPtr("Updated Username"),
			Email:    utils.StringPtr("Updated Email"),
		}

		mock.ExpectQuery("UPDATE users SET").
			WithArgs(
				"Updated Username",
				"Updated Email",
				999,
			).
			WillReturnError(sql.ErrNoRows)

		id, err := store.UpdateByID(context.Background(), 999, updates)

		assert.Nil(t, id)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		updates := types.UpdateUserPayload{
			Username: utils.StringPtr("Updated Username"),
			Email:    utils.StringPtr("Updated Email"),
		}

		mock.ExpectQuery("UPDATE users SET").
			WithArgs(
				"Updated Username",
				"Updated Email",
				1,
			).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.UpdateByID(context.Background(), 1, updates)

		assert.Error(t, err)
		assert.Zero(t, id)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully update user", func(t *testing.T) {
		updates := types.UpdateUserPayload{
			Username: utils.StringPtr("Updated Username"),
			Email:    utils.StringPtr("Updated Email"),
		}
		mock.ExpectQuery("UPDATE users SET").
			WithArgs(
				"Updated Username",
				"Updated Email",
				1,
			).
			WillReturnRows(sqlmock.NewRows([]string{
				"id", "username", "email", "created_at", "updated_at", "deleted_at",
			}).AddRow(
				1,
				"Updated Username",
				"Updated Email",
				time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC),
				time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC),
				time.Date(0001, 1, 1, 0, 0, 0, 0, time.UTC),
			))

		result, err := store.UpdateByID(context.Background(), 1, updates)

		assert.NoError(t, err)
		assert.NotNil(t, result)
		assert.Equal(t, 1, result.ID)
		assert.Equal(t, "Updated Username", result.Username)
		assert.Equal(t, "Updated Email", result.Email)

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err)
	})
}

func TestDeleteByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	store := NewUserStore(db)

	t.Run("database did not find any row", func(t *testing.T) {
		mock.ExpectQuery("UPDATE users SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnError(sql.ErrNoRows)

		id, err := store.DeleteByID(context.Background(), 1)

		assert.Equal(t, id, 0)
		assert.Error(t, err)
		assert.Equal(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("database unexpected error", func(t *testing.T) {
		mock.ExpectQuery("UPDATE users SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnError(fmt.Errorf("database connection error"))

		id, err := store.DeleteByID(context.Background(), 1)

		assert.Error(t, err)
		assert.Zero(t, id)
		assert.NotEqual(t, err, sql.ErrNoRows)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})

	t.Run("successfully delete user by ID", func(t *testing.T) {
		mock.ExpectQuery("UPDATE users SET deleted_at").
			WithArgs(1, sqlmock.AnyArg()).
			WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

		id, err := store.DeleteByID(context.Background(), 1)
		expectedID := 1

		assert.NoError(t, err)
		assert.Equal(t, expectedID, id)

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("unmet expectations: %v", err)
		}
	})
}

================
File: service/user/store.go
================
package user

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/hoyci/book-store-api/types"
	"github.com/hoyci/book-store-api/utils"
	"github.com/lib/pq"
)

type UserStore struct {
	db *sql.DB
}

func NewUserStore(db *sql.DB) *UserStore {
	return &UserStore{db: db}
}

func (s *UserStore) Create(ctx context.Context, newUser types.CreateUserDatabasePayload) (*types.UserResponse, error) {
	user := &types.UserResponse{}

	err := s.db.QueryRowContext(
		ctx,
		"INSERT INTO users (username, email, password_hash) VALUES ($1, $2, $3) RETURNING id, username, email, created_at, updated_at, deleted_at",
		newUser.Username,
		newUser.Email,
		newUser.PasswordHash,
	).Scan(
		&user.ID,
		&user.Username,
		&user.Email,
		&user.CreatedAt,
		&user.UpdatedAt,
		&user.DeletedAt,
	)

	if err != nil {
		return nil, err
	}

	return user, nil
}

func (s *UserStore) GetByID(ctx context.Context, id int) (*types.UserResponse, error) {
	user := &types.UserResponse{}

	err := s.db.QueryRowContext(ctx, "SELECT id, username, email, created_at, updated_at, deleted_at  FROM users WHERE id = $1 AND deleted_at IS null", id).
		Scan(
			&user.ID,
			&user.Username,
			&user.Email,
			&user.CreatedAt,
			&user.UpdatedAt,
			&user.DeletedAt,
		)
	if err != nil {
		return nil, err
	}

	return user, nil
}

func (s *UserStore) GetByEmail(ctx context.Context, email string) (*types.UserResponse, error) {
	user := &types.UserResponse{}
	err := s.db.QueryRowContext(ctx, "SELECT id, username, email, created_at, updated_at, deleted_at FROM users WHERE email = $1 AND deleted_at IS null", email).
		Scan(
			&user.ID,
			&user.Username,
			&user.Email,
			&user.CreatedAt,
			&user.UpdatedAt,
			&user.DeletedAt,
		)
	if err != nil {
		return nil, err
	}

	return user, nil
}

func (s *UserStore) UpdateByID(ctx context.Context, id int, newUser types.UpdateUserPayload) (*types.UserResponse, error) {
	query := fmt.Sprintf("UPDATE users SET updated_at = '%s', ", time.Now().Format("2006-01-02 15:04:05"))
	args := []any{}
	counter := 1

	fields := []struct {
		name  string
		value any
	}{
		{"username", newUser.Username},
		{"email", newUser.Email},
	}

	for _, field := range fields {
		if !utils.IsNil(field.value) {
			query += fmt.Sprintf("%s = $%d, ", field.name, counter)
			if ptr, ok := field.value.(*[]string); ok {
				args = append(args, pq.Array(*ptr))
			} else {
				args = append(args, field.value)
			}
			counter++
		}
	}

	if len(args) == 0 {
		return nil, fmt.Errorf("no fields to update for user with ID %d", id)
	}

	query = query[:len(query)-2] + fmt.Sprintf(" WHERE id = $%d RETURNING id, username, email, created_at, updated_at, deleted_at", counter)
	args = append(args, id)

	updatedUser := &types.UserResponse{}
	err := s.db.QueryRowContext(ctx, query, args...).Scan(
		&updatedUser.ID,
		&updatedUser.Username,
		&updatedUser.Email,
		&updatedUser.CreatedAt,
		&updatedUser.UpdatedAt,
		&updatedUser.DeletedAt,
	)
	if err != nil {
		return nil, err
	}

	return updatedUser, nil
}

func (s *UserStore) DeleteByID(ctx context.Context, id int) (int, error) {
	var returnedID int
	err := s.db.QueryRowContext(
		ctx,
		"UPDATE users SET deleted_at = $2 WHERE id = $1 RETURNING id",
		id,
		time.Now(),
	).Scan(&returnedID)
	if err != nil {
		return 0, err
	}

	return returnedID, nil
}

================
File: types/api.go
================
package types

type NotFoundResponse struct {
	Error string `json:"error"`
}

================
File: types/auth.go
================
package types

import (
	"context"
	"time"
)

type AuthStore interface {
	GetRefreshTokenByUserID(ctx context.Context, userID int) (*RefreshToken, error)
	UpsertRefreshToken(ctx context.Context, payload UpdateRefreshTokenPayload) error
}

type UserLoginPayload struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=8"`
}

type UserLoginResponse struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

type RefreshTokenPayload struct {
	RefreshToken string `json:"refresh_token" validate:"required"`
}

type RefreshToken struct {
	ID        int       `db:"id"`
	UserID    int       `db:"user_id"`
	Jti       string    `db:"jti"`
	ExpiresAt time.Time `db:"expires_at"`
	CreatedAt time.Time `db:"created_at"`
}

type UpdateRefreshTokenPayload struct {
	UserID    int       `db:"user_id"`
	Jti       string    `db:"jti"`
	ExpiresAt time.Time `db:"expires_at"`
}

type UpdateRefreshTokenResponse struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

================
File: types/book.go
================
package types

import (
	"context"
	"time"
)

type BookStore interface {
	Create(ctx context.Context, book CreateBookPayload) (int, error)
	GetByID(ctx context.Context, id int) (*Book, error)
	UpdateByID(ctx context.Context, id int, book UpdateBookPayload) (*Book, error)
	DeleteByID(ctx context.Context, id int) (int, error)
}

type Book struct {
	ID            int        `json:"id"`
	Name          string     `json:"name"`
	Description   string     `json:"description"`
	Author        string     `json:"author"`
	Genres        []string   `json:"genres"`
	ReleaseYear   int        `json:"release_year"`
	NumberOfPages int        `json:"number_of_pages"`
	ImageUrl      string     `json:"image_url"`
	CreatedAt     time.Time  `json:"created_at"`
	DeletedAt     *time.Time `json:"deleted_at"`
	UpdatedAt     *time.Time `json:"updated_at"`
}

type CreateBookPayload struct {
	Name          string   `json:"name" validate:"required,min=3"`
	Description   string   `json:"description" validate:"required,min=5"`
	Author        string   `json:"author" validate:"required,min=3"`
	Genres        []string `json:"genres" validate:"required,dive,min=1"`
	ReleaseYear   int      `json:"release_year" validate:"required,gte=1500,lte=2099"`
	NumberOfPages int      `json:"number_of_pages" validate:"required,gte=1"`
	ImageUrl      string   `json:"image_url" validate:"required,url"`
}

type CreateBookResponse struct {
	ID int `json:"id"`
}

type UpdateBookPayload struct {
	Name          *string   `json:"name,omitempty" validate:"omitempty,min=3"`
	Description   *string   `json:"description,omitempty" validate:"omitempty,min=5"`
	Author        *string   `json:"author,omitempty" validate:"omitempty,min=3"`
	Genres        *[]string `json:"genres,omitempty" validate:"omitempty,dive,min=1"`
	ReleaseYear   *int      `json:"release_year,omitempty" validate:"omitempty,gte=1500,lte=2099"`
	NumberOfPages *int      `json:"number_of_pages,omitempty" validate:"omitempty,gte=1"`
	ImageUrl      *string   `json:"image_url,omitempty" validate:"omitempty,url"`
}

type DeleteBookByIDResponse struct {
	ID int `json:"id"`
}

================
File: types/healthcheck.go
================
package types

type HealthcheckResponse struct {
	Status     string            `json:"status"`
	SystemInfo map[string]string `json:"system_info"`
}

================
File: types/user.go
================
package types

import (
	"context"
	"time"
)

type UserStore interface {
	Create(ctx context.Context, user CreateUserDatabasePayload) (*UserResponse, error)
	GetByID(ctx context.Context, id int) (*UserResponse, error)
	GetByEmail(ctx context.Context, email string) (*UserResponse, error)
	UpdateByID(ctx context.Context, id int, user UpdateUserPayload) (*UserResponse, error)
	DeleteByID(ctx context.Context, id int) (int, error)
}

type User struct {
	ID           int        `json:"id"`
	Username     string     `json:"username"`
	Email        string     `json:"email"`
	PasswordHash string     `json:"passwordHash"`
	CreatedAt    time.Time  `json:"createdAt"`
	DeletedAt    *time.Time `json:"deletedAt"`
	UpdatedAt    *time.Time `json:"updatedAt"`
}

type UserResponse struct {
	ID        int        `json:"id"`
	Username  string     `json:"username"`
	Email     string     `json:"email"`
	CreatedAt time.Time  `json:"createdAt"`
	DeletedAt *time.Time `json:"deletedAt"`
	UpdatedAt *time.Time `json:"updatedAt"`
}

type CreateUserRequestPayload struct {
	Username        string `json:"username" validate:"required,min=5"`
	Email           string `json:"email" validate:"required,email"`
	Password        string `json:"password" validate:"required,min=8"`
	ConfirmPassword string `json:"confirm_password" validate:"required,min=8"`
}

type CreateUserByIDResponse struct {
	ID int `json:"id"`
}

type CreateUserDatabasePayload struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"passwor_hash"`
}

type UpdateUserPayload struct {
	Username *string `json:"username,omitempty" validate:"omitempty,min=5"`
	Email    *string `json:"email,omitempty" validate:"omitempty,email"`
}

type DeleteUserByIDResponse struct {
	ID int `json:"id"`
}

================
File: types/uuid.go
================
package types

type UUIDGenerator interface {
	New() string
}

================
File: utils/json.go
================
package utils

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/sirupsen/logrus"
)

func ParseJSON(r *http.Request, payload any) error {
	if r.Body == nil {
		return fmt.Errorf("missing request body")
	}

	return json.NewDecoder(r.Body).Decode(payload)
}

func WriteJSON(w http.ResponseWriter, status int, v any) error {
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(status)
	return json.NewEncoder(w).Encode(v)
}

func WriteError(w http.ResponseWriter, status int, err error, context string, errorMessage string, clientErrorMessage any) {
	Log.WithFields(logrus.Fields{
		"error":   err.Error(),
		"context": context,
	}).Error(errorMessage)

	WriteJSON(
		w,
		status,
		map[string]any{
			"error": clientErrorMessage,
		},
	)
}

================
File: utils/jwt.go
================
package utils

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/hoyci/book-store-api/types"
)

type CustomClaims struct {
	ID       string `json:"id"`
	UserID   int    `json:"userId"`
	Username string `json:"username"`
	Email    string `json:"email"`
	jwt.RegisteredClaims
}

func CreateJWT(userID int, username string, email string, secretKey string, expTimeInSeconds int64, uuidGen types.UUIDGenerator) (string, error) {
	jti := uuidGen.New()

	claims := CustomClaims{
		UserID:   userID,
		Username: username,
		Email:    email,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(expTimeInSeconds) * time.Second)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			Issuer:    "book-store-api",
			ID:        jti,
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	signedToken, err := token.SignedString([]byte(secretKey))
	if err != nil {
		return "", fmt.Errorf("error signing token: %w", err)
	}

	return signedToken, nil
}

func VerifyJWT(tokenString, secretKey string) (*CustomClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(secretKey), nil
	})

	if err != nil {
		return nil, fmt.Errorf("error parsing token: %w", err)
	}

	if claims, ok := token.Claims.(*CustomClaims); ok && token.Valid {
		return claims, nil
	}
	return nil, fmt.Errorf("invalid token")
}

================
File: utils/logger.go
================
package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/sirupsen/logrus"
)

var Log *logrus.Logger

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func InitLogger() {
	Log = logrus.New()
	Log.SetOutput(os.Stdout)
	Log.SetFormatter(&logrus.TextFormatter{
		ForceColors:     true,
		FullTimestamp:   true,
		TimestampFormat: "2006-01-02 15:04:05",
	})
	Log.SetLevel(logrus.DebugLevel)
}

func LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
		next.ServeHTTP(rw, r)

		duration := time.Since(start)
		Log.WithFields(logrus.Fields{
			"method":      r.Method,
			"url":         r.URL.String(),
			"status_code": rw.statusCode,
			"duration_ms": duration.Milliseconds(),
			"remote_addr": r.RemoteAddr,
			"user_agent":  r.UserAgent(),
		}).Info("API Request")
	})
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

================
File: utils/password.go
================
package utils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}

func CheckPassword(hashedPassword, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	return err == nil
}

================
File: utils/utils.go
================
package utils

import (
	"time"
)

func StringPtr(s string) *string {
	return &s
}

func IntPtr(i int) *int {
	return &i
}

func TimePtr(t time.Time) *time.Time {
	return &t
}

func IsNil(value any) bool {
	switch v := value.(type) {
	case *string:
		return v == nil
	case *int:
		return v == nil
	case *[]string:
		return v == nil
	default:
		return value == nil
	}
}

================
File: utils/uuid.go
================
package utils

import "github.com/google/uuid"

type UUIDGeneratorUtil struct{}

func (g *UUIDGeneratorUtil) New() string {
	return uuid.New().String()
}
